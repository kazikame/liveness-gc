\section{Introduction}
\label{sec:intro}

Functional  programming  languages  depend  on  garbage  collector  to
efficiently  reclaim  unused  memory   allocated  by  programs  either
explicitly (for example using constructors) or implicitly (for example
for      closures).       However,      empirical      studies      on
Haskell~\cite{rojemo96lag},  Scheme~\cite{karkare06effectiveness}  and
Java~\cite{shaham02estimating}  programs   have  shown   that  garbage
collectors leave uncollected a lot of memory objects that are not live
(here {\em live}ness  means the object can potentially be  used by the
program at  a later  stage).  Due  to lack of  a suitable  analysis to
distinguish  reachable  objects  from live  objects.  current  garbage
collectors conservatively approximate the  liveness of heap objects by
their reachability from a set of memory locations called the {\em root
  set\/} resulting in unnecessary memory usage.

Languages having lazy  semantics for evaluation put  further demand on
memory as they  require heap allocated closure to be  carried from the
point of occurrence  of an expression to the point  of (first) real use
of  that expression.  Strictness analysis~\cite{some-refs}  statically
determines  the  patterns  of  future usage  of  an  expression,  thus
allowing some  of the  closures to  be evaluated at  the point  of the
occurrence of the corresponding expression.

We propose the  use of liveness analysis of heap  cells and strictness
analysis  of expressions  to  reduce the  memory  requirement of  lazy
functional  programming languages.   We modify  garbage collectors  to
preserve  only {\em  live} data---a  subset of  {\em reachable  data}.
This results in an increase  in the garbage reclaimed and consequently
in fewer  garbage collections.  Further, we eagerly evaluate closures
that are guaranteed to be evaluated in the future (strict closures).

The main contribution  of this paper is an uniform  framework for {\em
  liveness} and {\em strictness}  analysis to enable the optimizations
mentioned  above. Using  a central  notion of  demand, we  formulate a
context-sensitive liveness  analysis for structured data  and prove it
correct.  We then  present strictness as a dual of  liveness. We use a
0-CFA-like conservative approximation to  annotate each allocation and
function-call program point with  a finite-state automaton---which the
garbage-collector inspects to curtail reachability during marking. The
result of  the strictness analysis,  being necessarily finite,  can be
directly used to insert code to evaluate closures.

We previously proposed an interprocedural liveness analysis to improve
garbage collection first order eager subset of Scheme~\cite{cc-paper}.
The current paper extends the work to handle lazy evaluation semantics
for the same language.

Experiments  confirm  the  expected  performance benefits.  The  early
evaluation   of   closures  decreases   the   memory   demands  of   a
program. Further,  liveness-based collection results in  a increase in
garbage  reclaimed  and  a   consequent  decrease  in  the  number  of
collections, a decrease  in the memory size required  to run programs,
and  reduced  overall  garbage  collection  time  for  a  majority  of
programs.



%------------------------------------------------------------%
\subsubsection{Motivating Example}
\label{sec:motiv}

Figure~\ref{fig:mot-example}(a) shows  an example program.   The label
$\pi$ of an expression $e$  denotes a program point.  During execution
of  the program, it  represents the  instant of  time just  before the
evaluation  of  $e$.  
%%While we discuss liveness, it  will also be important to consider an
%%instance of time  just after the execution of  an expression, though
%%we shall not be required to mark it with a label.
% memory as  a (possibly  disconnected) directed
% acyclic   graph.\footnote{Since  the   language   under  consideration
%   (Section~\ref{sec:defs}) does not  have any imperative features, the
%   heap cannot  have cycles.}
% Here all data  is assumed to  be boxed, i.e.\
% stored in heap and accessed through references.
We  view the  heap  as a graph.  
Nodes in the heap, also  called  ($\CONS$) {\em  cells\/} contain $\CAR$ and $\CDR$ {\em fields}
containing values.  Edges in the graph are {\em references} and
emanate from {\em variables} or fields.
Variable and field values may also be atomic values ($\NIL$, integers etc.)
While it is convenient to box these in diagrams, our presented
analysis treats them as non-heap values.

Figure~\ref{fig:mot-example}(b)  shows the heap at $\pi$.
The edges shown  by thick arrows are those  which are made live by the
program. In addition,  assuming that
the value of any reachable part of the program result may be explored
or printed, the edges marked by thick dashed arrows are also live.
A cell  is  marked and preserved  during  garbage collection,  only  if it  is
reachable from the  root set through a path of  live edges.  All other
cells can be  reclaimed.  Thus if  a garbage collection takes
% place   at    the   time   represented   by   the    heap   shown   in
at $\pi$ with the    heap   shown   in
Figure~\ref{fig:mot-example}(b), only the cells $\pw$ and $(\CDR~ \pw)$, along with $(\CAR~(\CDR~\pw))$ and all cells reachable from it,
will be marked and preserved.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% MOTIVATING EXAMPLE
\newcommand{\nilfigure}
{\scalebox{0.75}{
\psset{unit=1mm,nodesep=0mm,labelsep=0.5mm}
\begin{pspicture}(0,0)(1,1)
%\psgrid[xunit=1cm,yunit=1cm,gridwidth=.2pt,subgridwidth=.1pt,subgriddiv=5,subgridcolor=gray,gridcolor=blue](0,0)(1,1)
\putnode{start}{origin}{0}{0}{}
\putnode{stop}{origin}{10}{10}{}
\ncline[offsetB=0,nodesepB=0,linewidth=.7]{-}{start}{stop} %here
\end{pspicture}
}}


\begin{figure}[t!]
%%%%{\color{Myblue}
\begin{picture}(100,130)(0,-90)
%  \begin{center}
    \begin{tabular}{cc}
\begin{boxedminipage}{.5\textwidth}
      {\sf
	\renewcommand{\arraystretch}{1}{
	  \begin{uprogram}
	  \UFL\ \hspace*{-.31\TAL} (\DEFINE\ (\append\  \lista\ \listb)
	  \UNL{0}  (\SIF~(\NULLQ \ \lista)
	       \listb
	  \UNL{1}      (\CONS\ (\CAR\  \lista)
%          \UNL{2}          (\CAR\  \lista)
	  \UNL{2}\;\;\;\;\;          (\append\ (\CDR\  \lista)
          \listb))))
          \UNL{0}
	  \UNL{0} \hspace*{-.49\TAL} (\LET\ z  $\leftarrow$(\CONS\ (\CONS\ $4$ (\CONS\ $5$ \NIL))
	  \UNL{3}\ \ \ \  (\CONS\ $6$ \NIL)) \IN
	  \UNL{0} (\LET\ y  $\leftarrow$ (\CONS\ $3$ \NIL) \IN
	  \UNL{1}   (\LET\ w $\leftarrow$ (\append\ y z)\ \IN
	  \UNL{1}               $\,\,\,\,\,\,\,\,\pi$:(\CAR\ (\CDR\ w)))))
	\end{uprogram}
      }} 
\end{boxedminipage}
      &
      \raisebox{-25mm}{\scalebox{.75}{
	%%%%%%%%%%%%%%%%%%%%%Uday's stuff%%%%%%%%%%%%%%%%%%%%%%%%%
      \psset{unit=1mm}
      \psset{linewidth=.3mm}
      \begin{pspicture}(0,-5)(70,60)
	%\psframe(0,0)(73,60)
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\putnode{o}{origin}{13}{50}{\TwoCells{o1}{o2}}
	\putnode{a}{o}{-10}{-15}{\psframebox{3}}
%	\putnode{b}{o}{10}{-15}{\psframebox[linestyle=none,framesep=.5]{\NIL}}
	\ncline[offsetB=-.5,nodesepB=.1]{*->}{o1}{a}
	%\aput[-3.5](.5){\scalebox{1.2}{\psframebox[framesep=.2,linestyle=none,fillstyle=solid,
	%      fillcolor=white]{$\times$}}}
        \putnode{b}{o}{0}{-3}{\psframebox[linestyle=none,framesep=.5]{\scalebox{.63}{\nilfigure}}}
%	\ncline[offsetB=-.5,nodesepB=.1]{*->}{o2}{b}
	%\ncline[offsetB=-.5,nodesepB=.1]{->}{o2}{b}
	\putnode{y}{o}{-14}{8}{\psframebox[linestyle=none,framesep=.5]{y}}
	\nccurve[nodesepB=-.2,angleA=330,angleB=120]{->}{y}{o}
	\aput[-3.5](.5){\scalebox{1.2}{\psframebox[framesep=.2,linestyle=none,fillstyle=solid,
		  fillcolor=white]{$\times$}}}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\putnode{c}{o}{25}{0}{\TwoCells{c1}{c2}}
	\putnode{d}{c}{10}{-10}{\TwoCells{d1}{d2}}
	\putnode{e}{d}{-13}{-12}{\TwoCells{e1}{e2}}
	\putnode{f}{d}{13}{-12}{\TwoCells{f1}{f2}}
	\ncline[nodesepB=-.5]{*->}{c2}{d}
	\ncline[nodesepB=-.5,linewidth=.7]{->}{c2}{d}
	\nccurve[ncurv=1,angleA=270,angleB=330]{*->}{c1}{a}
	\aput[-3.5](.2){\scalebox{1.2}{\psframebox[framesep=.2,linestyle=none,fillstyle=solid,
	      fillcolor=white]{$\times$}}}
	\nccurve[nodesepB=-.5,angleA=240,angleB=70]{*->}{d1}{e}
	\nccurve[nodesepB=-.5,angleA=240,angleB=70,linewidth=.7]{->}{d1}{e}
	\nccurve[nodesepB=-.5,angleA=300,angleB=110]{*->}{d2}{f}
	\aput[-3.5](.5){\scalebox{1.2}{\psframebox[framesep=.2,linestyle=none,fillstyle=solid,
	      fillcolor=white]{$\times$}}}
	\putnode{w}{c}{-8}{8}{\psframebox[linestyle=none,framesep=.2]{w}}
	\putnode{ww}{c}{15}{8}{\psframebox[linestyle=none,framesep=.2]{z}}
	\nccurve[nodesepB=-.2,angleA=330,angleB=120,linewidth=.7]{->}{w}{c}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\putnode{g}{e}{-8}{-12}{\psframebox{4}}
	\putnode{h}{e}{8}{-14}{\TwoCells{h1}{h2}}
	\putnode{i}{f}{-8}{-11}{\psframebox{6}}
%	\putnode{j}{f}{8}{-11}{\psframebox[linestyle=none,framesep=.5]{\NIL}}
	\ncline[offsetB=-.5,nodesepB=.1]{*-}{e1}{e1}
	\ncline[linestyle=dashed,offsetB=-.5,nodesepB=.1,linewidth=.7]{->}{e1}{g}
        %here
        \putnode{j1}{f}{0}{-3}{\psframebox[linestyle=none,framesep=0]{\scalebox{.63}{\nilfigure}}}
        \putnode{j2}{h}{0}{-3}{\psframebox[linestyle=none,framesep=.5]{\scalebox{.63}{\nilfigure}}}

%        \aput[-3.2](.6){\scalebox{1.2}{\psframebox[framesep=.1,linestyle=none,fillstyle=solid,
%	      fillcolor=white]{$\times$}}} %and here
	\ncline[offsetB=-.5,nodesepB=-.3]{*-}{e2}{e2}
	\ncline[linestyle=dashed,offsetB=-.5,nodesepB=.1,linewidth=.7]{->}{e2}{h} 
%	\aput[-3.2](.5){\scalebox{1.2}{\psframebox[framesep=.1,linestyle=none,fillstyle=solid,
%	      fillcolor=white]{$\times$}}} %and here

	\ncline[offsetB=-.5,nodesepB=.1]{*->}{f1}{i}
	\ncline[offsetB=-.5,nodesepB=.1]{*->}{f2}{j}
	\nccurve[nodesepB=-.2,angleA=270,angleB=90]{->}{ww}{d}
	\aput[-3.2](.4){\scalebox{1.2}{\psframebox[framesep=.1,linestyle=none,fillstyle=solid,
	      fillcolor=white]{$\times$}}}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\putnode{k}{h}{-8}{-11}{\psframebox{5}}
%	\putnode{l}{h}{8}{-11}{\psframebox[linestyle=none,framesep=.5]{\NIL}}
	\ncline[offsetB=-.5,nodesepB=.1]{*-}{h1}{h1}
	\ncline[linestyle=dashed,offsetB=-.5,nodesepB=.1,linewidth=.7]{->}{h1}{k}
%	\ncline[offsetB=-.5,nodesepB=.1]{*->}{h2}{l}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      \end{pspicture}}} \\
      (a) Example program.&
      \renewcommand{\arraystretch}{.9}{\begin{tabular}[t]{ll}
	(b) Memory graph at $\pi$. Thick edges denote \\
        {\white (b) }live links. Traversal stops at edges marked\\
        {\white (b) }$\times$  during garbage collection.
      \end{tabular}}
    \end{tabular}
\end{picture}

\kern -3ex

\caption{Example Program and its Memory Graph.}\label{fig:mot-example}    
%  \end{center}
%%%%}\color{Myblue} end
\end{figure}


\subsubsection{Organization of the paper}
Section~\ref{sec:defs} gives
the syntax and semantics of
the language used to illustrate our analysis along with basic concepts
and    notations.
% Section~\ref{sec:operational}   describes    the
% operational semantics  of the  language.
Liveness analysis is described in
Section~\ref{sec:liveness} followed by a sketch of a correctness
proof relative to a non-standard semantics.
Section~\ref{sec:computing} shows how to encode liveness as
finite-state automata.
Section~\ref{sec:experiments}   reports   experimental   results and
Section~\ref{sec:lgc-always-better} proves that a liveness based
collector can never do more garbage collections than a reachability
based collector. 
% and Section~\ref{sec:conclusion} concludes the paper.




\section{The target language---syntax and semantics}
\label{sec:defs}
We let $x$, $y$, $z$ range over variables, $f$ over user-functions and
$p$ over  primitive functions ($\CONS$, $\PRIM$ etc.).   The syntax of
our language  is shown  in Figure~\ref{fig:lang-syntax}; it  has eager
semantics and  restricts programs to be in  Administrative Normal Form
(ANF)~\cite{chakravarty03perspective}  where all actual  parameters to
functions   are   variables.   This   restriction   does  not   affect
expressibility (and indeed we feel  free to ignore it in examples when
inessential). In addition, this  form also explicates the formation of
closures.  We further  require  that  each variable  in  a program  is
distinct, so  that no scope shadowing  occurs---this simplifies proofs
of soundness.  In this  formulation expressions: either perform a test
($\SIF$), make a computation step ($\LET$) or return ($\RETURN$).  The
$\RETURN$ keyword is logically redundant, but we find it clarifies the
semantics and analysis.


The body of the program is
the  expression denoted  by  $e_\mainpgm$; for analysis purposes
it is convenient
to regard $e_\mainpgm$ as part of a function definition
$(\DEFINE\ ({\tt main})\ e_\mainpgm)$ as in C\@.
% As  mentioned earlier,
We write  $\pi\!:\!e$ to  associate the label  $\pi$ (not part  of the
language syntax) with the program point just before expression $e$.

% \paragraph{Inlining.}
In spite of the ANF restrictions it is still possible
to inline non-recursive functions (a fact we use to prove the safety
of liveness analysis).  A user-function call
$(\LET\,\, x \leftarrow (f\,y_1\,\ldots\,y_n) \,\, \IN\,\, e)$
to a function defined
(after renaming its formals and locals to be disjoint from existing variables)
by $(\DEFINE\ (f\ z_1\ \ldots\ z_n)\ e_f)$
is replaced by a sequence of $\LET$'s of the form
$z_i\leftarrow (\ID\,\,y_i)$ followed by
the body $e_f$ but with its $(\RETURN\,\,w)$ expressions replaced by
$(\LET\,\, x \leftarrow (\ID\,\, w) \,\, \IN\,\, e)$.

\begin{figure}[t!]
\footnotesize
\begin{eqnarray*}
   p \in \mathit{Prog} & ::= & d_1 \ldots d_n \,\, e_\mainpgm
    \hspace{7em} \mbox{\em --- program}\\
    d \in Fdef & ::= & (\DEFINE\,\, (f\,\, x_1 \,\, \ldots \,\,x_n)\,\,
    e) 
    \hspace{1.7em} \mbox{\em --- function definition} \\
e \in \mathit{Expr} & ::= &
\left\{\begin{array}{ll@{\hspace{4em}}l}
       (\SIF\,\, x\,\, e_1\,\, e_2) && \mbox{\em --- conditional} \\ 
       (\LET\,\, x \leftarrow s\,\, \IN\,\, e) && \mbox{\em --- let binding} \\
       (\RETURN\,\, x) && \mbox{\em --- return from function}
    \end{array}\right. \\
s \in \mathit{Stmt} & ::= &
\left\{\begin{array}{lr@{\hspace{1em}}l}
       k && \mbox{\em --- constant (numeric or $\NIL$)}\\
       (\CONS\,\, x_1\,\, x_2) && \mbox{\em --- constructor} \\ 
       (\CAR\,\, x) &  (\CDR\,\, x) & \mbox{\em --- selectors} \\ 
       (\NULLQ\,\, x) & (\PRIM\,\, x_1\,\, x_2) & \mbox{\em ---  tester and generic arithmetic} \\ 
%        (\NULLQ\,\, x) && \mbox{\em ---  tester} \\ 
       (\ID\,\, x) && \mbox{\em ---  identity function (for inlining)} \\ 
%        (\PRIM\,\, x_1\,\, x_2) && \mbox{\em --- generic arithmetic} \\ 
       \multicolumn{2}{l}{(f\,\, x_1\,\,\ldots\,\, x_n)} 
            & \mbox{\em --- function application} 
    \end{array}\right.
\end{eqnarray*}
  \caption{The syntax of our language}\label{fig:lang-syntax}
\figrule
\normalsize
\end{figure}


\subsubsection{Semantics}
We now give an operational
semantics for  our language.  Later, a refinement of
the  operational semantics,  which we  call minefield  semantics, will
serve to prove liveness analysis correct.
We give a small-step semantics because, unlike big-step semantics,
correctness for non-terminating programs does not need special treatment.
We start with the domains used by the semantics:
\[
\begin{array}{rlcl@{\hspace{2em}}l}
\rho: & \mathit{Env} &=&\mathit{Var} \rightarrow {Loc} & \mbox{-- Environment} \\ 
v:   & \mathit{Val} &=& \mathbb{N} + \{\NIL\} + \mathit{Val \times
  Val}& \mbox{-- Values}\\
c:   & \mathit{Clo} &=& \mathit{(Exp \times Env)}& \mbox{-- Closures}\\
\heap: & \mathit{Heap} & =&\mathit{Loc} \rightarrow (\mathit{Val} +
\mathit{Clo}) & \mbox{-- Heap}
\end{array}
\]
%Note that in the eager case, if a cons had a numeric argument, this
%fact was known when the cons was created. Thus you could have unboxed
%numbers. This is not possible now. For instance, the argument of a
%cons could be a closure which evaluates to a number.
%Decision - numbers are boxed
Here $\mathit{Loc}$ is countable set  of locations in the heap.  Since
all data objects are boxed, we  model an environment as a mapping from
the set of variables of the program $\mathit{Var}$ to locations in the
heap.  These either contain a value  in WHNF (a number, the empty list
$\NIL$, or  a \CONS\ cell)  or a {\em  closure}.  A closure is  a pair
$(s, \rho)$ in which $s$ is an unevaluated application with the values
of its free variables supplied by $\rho$.

Finally, $\stk$  is a stack (using  $\bullet$ for push  and $[\,]$ for
empty stack)  of frames  of unfinished function  calls.  A frame  is a
triple  $(e,x,\rho)$   representing  the  call  site   $  (\LET\,\,  x
\leftarrow (f\,y_1\,\ldots\,y_n) \,\, \IN\,\,  e) $ being evaluated in
environment $\rho$.   Frames can also  be viewed as  continuations, in
this view  the ({\sc ord-return})  rule in the  small-step operational
semantics (Figure~\ref{fig:lang-opsem-small}) invokes them.

The semantics of statements $s$ are given by the judgement form $\rho,
\heap, s \rightsquigarrow \heap', v$  and those for expressions $e$ by
the form $\rho, \stk, \heap,  e \rightarrow \rho', \stk', \heap', e'$.
The  start state is  $(\{\},[\,], \{\},  e_\mainpgm)$ and  the program
terminates successfully  with result  value $\rho(x)$ on  reaching the
halt state $(\rho,[\,], \heap, (\RETURN\ x))$

Notation: we write $\rho[x \mapsto v]$ for the environment which is as
$\rho$ but  has value $v$ at  $x$.  We also  write $[\myvec{x} \mapsto
  \myvec{v}]$  which respectively  has  values $v_1,  \ldots, v_n$  at
$x_1,  \ldots, x_n$  and write  $[\myvec{x}  \mapsto \rho(\myvec{y})]$
when $v_1, \ldots, v_n$ are $\rho(y_1), \ldots, \rho(y_n)$.

\paragraph{Stuck states.} Note that certain forms of $e$ do not reduce
with  $\rightarrow$  (perhaps  because  $\rightsquigarrow$  could  not
reduce a  contained $s$).  Some  of these we  eliminate syntactically,
e.g.\ ensuring all variables and  functions are defined and are called
with the correct number  of parameters.  Others include $(\CDR\ \NIL),
(\CAR\ 3),  (+\ \NIL\ 4)$ and  $(\SIF\ \NIL\ e_1\ e_2)$.   All but the
first can  be eliminated with a  static type system  but, treating our
program as dynamically typed, we regard all these as stuck states.

\begin{figure}[t!]
\begin{tabular}{|l|l|c|}
\hline
Condition & Transition & Rule name \\
\hline
          & $\rho, (\rho', x, e)\!:\!S, H, \kappa
  \rightsquigarrow \rho', S, H[\rho'(x) \mapsto \kappa], e$    &  \sc{const} \\
\hline
          & \shortstack[l]{$\rho, (\rho', z, e)\!:\!S, H, (\CONS~x~y)  \rightsquigarrow
$ \\  $\rho', S, H[z \mapsto (H(\rho(x)),H(\rho(y)))], e$}     &  \sc{cons} \\
\hline
$H(\rho(x)) \mbox{ is } (v_1, v_2)$ & $\rho, (\rho', z, e)\!:\!S, H,
(\CAR~x)  \rightsquigarrow \rho', S, H[\rho(z) \mapsto v_1], e$      &  \sc{car-whnf} \\
\hline
$H(\rho(x)) \mbox{ is } (e, \rho')$ & $\rho, S, H, (\CAR~x)  \rightsquigarrow
\rho'\oplus\rho, (\rho, x, (\CAR~x))\!:\!S, H, e$      &  \sc{car-clo} \\
\hline
$H(\rho(x)), H(\rho(y)) \in \mathbb{N}$
 & \shortstack[l]{$\rho, (\rho', z, e)\!:\!S, H, (+~x~y)  \rightsquigarrow$ \\
$\rho', S, H[\rho(z) \mapsto H(\rho(x)) + H(\rho(y))], e$}      &  \sc{prim-whnf} \\
\hline
$H(\rho(x)) \mbox{ is } (e, \rho')$ & $\rho, S, H, (+~x~y)  \rightsquigarrow
\rho'\oplus\rho, (\rho, x, (+~x~y))\!:\!S, H, e$      &  \sc{prim-1-clo} \\
\hline
$H(\rho(y)) \mbox{ is } (e, \rho')$ & $\rho, S, H, (+~x~y)  \rightsquigarrow
\rho'\oplus\rho, (\rho, x, (+~x~y))\!:\!S, H, e$      &  \sc{prim-2-clo} \\
\hline
\shortstack[l]{$\mathit{f}~\mbox{defined as}$ \\ $~(\DEFINE~(f~\myvec{y})~e_{\mathit{f}})$}  & $\rho, S, H, (f~\myvec{x})  \rightsquigarrow
[\rho(\myvec{x})/\myvec{y}], S, H, e_{\mathit{f}}$      &  \sc{funcall} \\
\hline
$\ell$ is a new location& \shortstack[l]{$\rho, S, H, (\LET~x\leftarrow s~\IN~e)
  \rightsquigarrow$ \\
$[x \mapsto \ell]\oplus\rho, S, H[\ell \mapsto (s, (x \mapsto
  \ell)\oplus\lfloor \rho\rfloor_{FV(S)-\{x\}})], e$} & \sc{let} \\ 
\hline
$H(\rho(x)) \ne 0$ & $\rho, S, H, (\SIF~x~e_1~e_2)   \rightsquigarrow
\rho, S, H,  e_1$ & \sc{if-true} \\ 
\hline
$H(\rho(x)) = 0$ & $\rho, S, H, (\SIF~x~e_1~e_2)   \rightsquigarrow
\rho, S, H,  e_2$ & \sc{if-false} \\ 
\hline
$H(\rho(x)) = (e,\rho')$ & \shortstack[l]{$\rho, S, H,
  (\SIF~x~e_1~e_2)   \rightsquigarrow$ \\ 
$\rho'\oplus\rho, (\rho, x, (\IF~x~e_1~e_2))\!:\!S, H,  e$} & \sc{if-clo} \\ 
\hline
\shortstack[l]{$H(\rho(x))~\mbox{is}$ \\$\mbox{whnf with value}~v$}& $\rho, (\rho', z, e)\!:\!S, H,
(\RETURN~x)  \rightsquigarrow \rho', S, H[\rho(z) \mapsto v], e$ & \sc{return-whnf}\\   
\hline
$H(\rho(x)) = (e,\rho')$ & \shortstack[l]{$\rho, S, H, (\RETURN~x)
  \rightsquigarrow$ \\
$\rho'\oplus\rho,~ (\rho, x, (\RETURN~x))\!:\!S, H,  e$} & \sc{return-clo} \\
\hline
\end{tabular}
\caption{A small-step semantics for the language}\label{fig:lang-semantics}
\end{figure}
%==============================================================
\renewcommand{\pp}[2]{\ensuremath{#1\!\!:\!#2}} % prog point


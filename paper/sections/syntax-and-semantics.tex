<<<<<<< HEAD


\section{The target language---syntax and semantics}
\label{sec:defs}
We let $x$, $y$, $z$ range over variables, $f$ over user-functions and
$p$ over  primitive functions ($\CONS$, $\PRIM$ etc.).   The syntax of
our language  is shown  in Figure~\ref{fig:lang-syntax}; it  has eager
semantics and  restricts programs to be in  Administrative Normal Form
(ANF)~\cite{chakravarty03perspective}  where all actual  parameters to
functions   are   variables.   This   restriction   does  not   affect
expressibility (and indeed we feel  free to ignore it in examples when
inessential). In addition, this  form also explicates the formation of
closures.  We further  require  that  each variable  in  a program  is
distinct, so  that no scope shadowing  occurs---this simplifies proofs
of soundness.  In this  formulation expressions: either perform a test
($\SIF$), make a computation step ($\LET$) or return ($\RETURN$).  The
$\RETURN$ keyword is logically redundant, but we find it clarifies the
semantics and analysis.


The body of the program is
the  expression denoted  by  $e_\mainpgm$; for analysis purposes
it is convenient
to regard $e_\mainpgm$ as part of a function definition
$(\DEFINE\ ({\tt main})\ e_\mainpgm)$ as in C\@.
% As  mentioned earlier,
We write  $\pi\!:\!e$ to  associate the label  $\pi$ (not part  of the
language syntax) with the program point just before expression $e$.

% \paragraph{Inlining.}
In spite of the ANF restrictions it is still possible
to inline non-recursive functions (a fact we use to prove the safety
of liveness analysis).  A user-function call
$(\LET\,\, x \leftarrow (f\,y_1\,\ldots\,y_n) \,\, \IN\,\, e)$
to a function defined
(after renaming its formals and locals to be disjoint from existing variables)
by $(\DEFINE\ (f\ z_1\ \ldots\ z_n)\ e_f)$
is replaced by a sequence of $\LET$'s of the form
$z_i\leftarrow (\ID\,\,y_i)$ followed by
the body $e_f$ but with its $(\RETURN\,\,w)$ expressions replaced by
$(\LET\,\, x \leftarrow (\ID\,\, w) \,\, \IN\,\, e)$.

\begin{figure}[t!]
\footnotesize
\begin{eqnarray*}
   p \in \mathit{Prog} & ::= & d_1 \ldots d_n \,\, e_\mainpgm
    \hspace{7em} \mbox{\em --- program}\\
    d \in Fdef & ::= & (\DEFINE\,\, (f\,\, x_1 \,\, \ldots \,\,x_n)\,\,
    e) 
    \hspace{1.7em} \mbox{\em --- function definition} \\
e \in \mathit{Expr} & ::= &
\left\{\begin{array}{ll@{\hspace{4em}}l}
       (\SIF\,\, x\,\, e_1\,\, e_2) && \mbox{\em --- conditional} \\ 
       (\LET\,\, x \leftarrow s\,\, \IN\,\, e) && \mbox{\em --- let binding} \\
       (\RETURN\,\, x) && \mbox{\em --- return from function}
    \end{array}\right. \\
s \in \mathit{Stmt} & ::= &
\left\{\begin{array}{lr@{\hspace{1em}}l}
       k && \mbox{\em --- constant (numeric or $\NIL$)}\\
       (\CONS\,\, x_1\,\, x_2) && \mbox{\em --- constructor} \\ 
       (\CAR\,\, x) &  (\CDR\,\, x) & \mbox{\em --- selectors} \\ 
       (\NULLQ\,\, x) & (\PRIM\,\, x_1\,\, x_2) & \mbox{\em ---  tester and generic arithmetic} \\ 
%        (\NULLQ\,\, x) && \mbox{\em ---  tester} \\ 
       (\ID\,\, x) && \mbox{\em ---  identity function (for inlining)} \\ 
%        (\PRIM\,\, x_1\,\, x_2) && \mbox{\em --- generic arithmetic} \\ 
       \multicolumn{2}{l}{(f\,\, x_1\,\,\ldots\,\, x_n)} 
            & \mbox{\em --- function application} 
    \end{array}\right.
\end{eqnarray*}
  \caption{The syntax of our language}\label{fig:lang-syntax}
\figrule
\normalsize
\end{figure}


\subsubsection{Semantics}
We now give an operational
semantics for  our language.  Later, a refinement of
the  operational semantics,  which we  call minefield  semantics, will
serve to prove liveness analysis correct.
We give a small-step semantics because, unlike big-step semantics,
correctness for non-terminating programs does not need special treatment.
We start with the domains used by the semantics:
\[
\begin{array}{rlcl@{\hspace{2em}}l}
\rho: & \mathit{Env} &=&\mathit{Var} \rightarrow {Loc} & \mbox{-- Environment} \\ 
v:   & \mathit{Val} &=& \mathbb{N} + \{\NIL\} + \mathit{Val \times
  Val}& \mbox{-- Values}\\
c:   & \mathit{Clo} &=& \mathit{(Exp \times Env)}& \mbox{-- Closures}\\
\heap: & \mathit{Heap} & =&\mathit{Loc} \rightarrow (\mathit{Val} +
\mathit{Clo}) & \mbox{-- Heap}
\end{array}
\]
%Note that in the eager case, if a cons had a numeric argument, this
%fact was known when the cons was created. Thus you could have unboxed
%numbers. This is not possible now. For instance, the argument of a
%cons could be a closure which evaluates to a number.
%Decision - numbers are boxed
Here $\mathit{Loc}$ is countable set  of locations in the heap.  Since
all data objects are boxed, we  model an environment as a mapping from
the set of variables of the program $\mathit{Var}$ to locations in the
heap.  These either contain a value  in WHNF (a number, the empty list
$\NIL$, or  a \CONS\ cell)  or a {\em  closure}.  A closure is  a pair
$(s, \rho)$ in which $s$ is an unevaluated application with the values
of its free variables supplied by $\rho$.

Finally, $\stk$  is a stack (using  $\bullet$ for push  and $[\,]$ for
empty stack)  of frames  of unfinished function  calls.  A frame  is a
triple  $(e,x,\rho)$   representing  the  call  site   $  (\LET\,\,  x
\leftarrow (f\,y_1\,\ldots\,y_n) \,\, \IN\,\,  e) $ being evaluated in
environment $\rho$.   Frames can also  be viewed as  continuations, in
this view  the ({\sc ord-return})  rule in the  small-step operational
semantics (Figure~\ref{fig:lang-opsem-small}) invokes them.

The semantics of statements $s$ are given by the judgement form $\rho,
\heap, s \rightsquigarrow \heap', v$  and those for expressions $e$ by
the form $\rho, \stk, \heap,  e \rightarrow \rho', \stk', \heap', e'$.
The  start state is  $(\{\},[\,], \{\},  e_\mainpgm)$ and  the program
terminates successfully  with result  value $\rho(x)$ on  reaching the
halt state $(\rho,[\,], \heap, (\RETURN\ x))$

Notation: we write $\rho[x \mapsto v]$ for the environment which is as
$\rho$ but  has value $v$ at  $x$.  We also  write $[\myvec{x} \mapsto
  \myvec{v}]$  which respectively  has  values $v_1,  \ldots, v_n$  at
$x_1,  \ldots, x_n$  and write  $[\myvec{x}  \mapsto \rho(\myvec{y})]$
when $v_1, \ldots, v_n$ are $\rho(y_1), \ldots, \rho(y_n)$.

\paragraph{Stuck states.} Note that certain forms of $e$ do not reduce
with  $\rightarrow$  (perhaps  because  $\rightsquigarrow$  could  not
reduce a  contained $s$).  Some  of these we  eliminate syntactically,
e.g.\ ensuring all variables and  functions are defined and are called
with the correct number  of parameters.  Others include $(\CDR\ \NIL),
(\CAR\ 3),  (+\ \NIL\ 4)$ and  $(\SIF\ \NIL\ e_1\ e_2)$.   All but the
first can  be eliminated with a  static type system  but, treating our
program as dynamically typed, we regard all these as stuck states.

\begin{figure}[t!]
\begin{tabular}{|l|l|c|}
\hline
Condition & Transition & Rule name \\
\hline
          & $\rho, (\rho', x, e)\!:\!S, H, \kappa
  \rightsquigarrow \rho', S, H[\rho'(x) \mapsto \kappa], e$    &  \sc{const} \\
\hline
          & \shortstack[l]{$\rho, (\rho', z, e)\!:\!S, H, (\CONS~x~y)  \rightsquigarrow
$ \\  $\rho', S, H[z \mapsto (H(\rho(x)),H(\rho(y)))], e$}     &  \sc{cons} \\
\hline
$H(\rho(x)) \mbox{ is } (v_1, v_2) & \rho, (\rho', z, e)\!:\!S, H,
(\CAR~x)  \rightsquigarrow \rho', S, H[\rho(z) \mapsto v_1], e$      &  \sc{car-whnf} \\
\hline
$H(\rho(x)) \mbox{ is } (e, \rho') & \rho, S, H, (\CAR~x)  \rightsquigarrow
\rho'\oplus\rho, (\rho, x, (\CAR~x))\!:\!S, H, e$      &  \sc{car-clo} \\
\hline
$H(\rho(x)), H(\rho(y)) \in \mathbb{N}$
 & \shortstack[l]{$\rho, (\rho', z, e)\!:\!S, H, (+~x~y)  \rightsquigarrow$ \\
$\rho', S, H[\rho(z) \mapsto H(\rho(x)) + H(\rho(y))], e$}      &  \sc{prim-whnf} \\
\hline
$H(\rho(x)) \mbox{ is } (e, \rho') & \rho, S, H, (+~x~y)  \rightsquigarrow
\rho'\oplus\rho, (\rho, x, (+~x~y))\!:\!S, H, e$      &  \sc{prim-1-clo} \\
\hline
$H(\rho(y)) \mbox{ is } (e, \rho') & \rho, S, H, (+~x~y)  \rightsquigarrow
\rho'\oplus\rho, (\rho, x, (+~x~y))\!:\!S, H, e$      &  \sc{prim-2-clo} \\
\hline
\shortstack[l]{$\mathit{f}~\mbox{defined as}$ \\ $~(\DEFINE~(f~\myvec{y})~e_{\mathit{f}})$}  & $\rho, S, H, (f~\myvec{x})  \rightsquigarrow
[\rho(\myvec{x})/\myvec{y}], S, H, e_{\mathit{f}}$      &  \sc{funcall} \\
\hline
$\ell$ is a new location& \shortstack[l]{$\rho, S, H, (\LET~x\leftarrow s~\IN~e)
  \rightsquigarrow$ \\
$[x \mapsto \ell]\oplus\rho, S, H[\ell \mapsto (s, (x \mapsto
  \ell)\oplus\lfloor \rho\rfloor_{FV(S)-\{x\}})], e$} & \sc{let} \\ 
\hline
$H(\rho(x)) \ne 0$ & $\rho, S, H, (\SIF~x~e_1~e_2)   \rightsquigarrow
\rho, S, H,  e_1$ & \sc{if-true} \\ 
\hline
$H(\rho(x)) = 0$ & $\rho, S, H, (\SIF~x~e_1~e_2)   \rightsquigarrow
\rho, S, H,  e_2$ & \sc{if-false} \\ 
\hline
$H(\rho(x)) = (e,\rho')$ & \shortstack[l]{$\rho, S, H,
  (\SIF~x~e_1~e_2)   \rightsquigarrow$ \\ 
$\rho'\oplus\rho, (\rho, x, (\IF~x~e_1~e_2))\!:\!S, H,  e$} & \sc{if-clo} \\ 
\hline
\shortstack[l]{$H(\rho(x))~\mbox{is}$ \\$\mbox{whnf with value}~v$}& $\rho, (\rho', z, e)\!:\!S, H,
(\RETURN~x)  \rightsquigarrow \rho', S, H[\rho(z) \mapsto v], e$ & \sc{return-whnf}\\   
\hline
$H(\rho(x)) = (e,\rho')$ & \shortstack[l]{$\rho, S, H, (\RETURN~x)
  \rightsquigarrow$ \\
$\rho'\oplus\rho,~ (\rho, x, (\RETURN~x))\!:\!S, H,  e$} & \sc{return-clo} \\
\hline
\end{tabular}
\caption{A small-step semantics for the language}\label{fig:lang-semantics}
\end{figure}
%==============================================================
\renewcommand{\pp}[2]{\ensuremath{#1\!\!:\!#2}} % prog point

=======


\section{The target language---syntax and semantics}
\label{sec:defs}
We let $x$, $y$, $z$ range over variables, $f$ over user-functions and
$p$    over    primitive    functions   ($\CONS$,    $\PRIM$    etc.).
Figure~\ref{fig:lang-syntax} describes the  syntax of our language. It
is a first  order language with lazy semantics  and restricts programs
to        be        in        Administrative        Normal        Form
(ANF)~\cite{chakravarty03perspective}  where all actual  parameters to
functions   are   variables.   This   restriction   does  not   affect
expressibility  (and we ignore  it in  examples when  inessential). In
addition, this  form also explicates the creation  of closures through
$\LET$s which are lazy.  A consequence  of lazy $\LET$ is that $x$ can
also occur  in $s$  in $\LET\,\, x  \leftarrow s\,\, \IN\,\,  e$. This
enables  creation of  graph-like structures  in a  pure  language. The
restriction of \LET\ to a single definition is for ease of exposition;
generalization  to  multiple  definitions  does  not  pose  conceptual
difficulties.  We  further restrict each  variable in a program  to be
distinct, so  that no scope shadowing  occurs---this simplifies proofs
of soundness.  The $\RETURN$  and \SIF\ expressions trigger evaluation
of  closures.

The body of the program is the expression denoted by $e_\mainpgm$; for
analysis purposes it is convenient to regard $e_\mainpgm$ as part of a
function definition $(\DEFINE\ ({\tt main})\ e_\mainpgm)$ as in C\@.
We write  $\pi\!:\!e$ to  associate the label  $\pi$ (not part  of the
language syntax) with the program point just before expression $e$.

% \paragraph{Inlining.}
{\color{Myblue}In spite of the ANF  restrictions it is still possible to
  inline non-recursive functions (a fact we use to prove the safety of
  liveness  analysis).  A user-function  call $(\LET\,\,  x \leftarrow
  (f\,y_1\,\ldots\,y_n) \,\, \IN\,\, e)$  to a function defined (after
  renaming  its  formals  and  locals  to be  disjoint  from  existing
  variables) by $(\DEFINE\ (f\ z_1\ \ldots\ z_n)\ e_f)$ is replaced by
  a  sequence of  $\LET$'s  of the  form $z_i\leftarrow  (\ID\,\,y_i)$
  followed by the body $e_f$ but with its $(\RETURN\,\,w)$ expressions
  replaced by $(\LET\,\, x \leftarrow (\ID\,\, w) \,\, \IN\,\, e)$.}

\begin{figure}[t!]
\footnotesize
\begin{eqnarray*}
   p \in \mathit{Prog} & ::= & d_1 \ldots d_n \,\, e_\mainpgm
    \hspace{7em} \mbox{\em --- program}\\
    d \in Fdef & ::= & (\DEFINE\,\, (f\,\, x_1 \,\, \ldots \,\,x_n)\,\,
    e) 
    \hspace{1.7em} \mbox{\em --- function definition} \\
e \in \mathit{Expr} & ::= &
\left\{\begin{array}{ll@{\hspace{4em}}l}
       (\SIF\,\, x\,\, e_1\,\, e_2) && \mbox{\em --- conditional} \\ 
       (\LET\,\, x \leftarrow s\,\, \IN\,\, e) && \mbox{\em --- let binding} \\
       (\RETURN\,\, x) && \mbox{\em --- return from function}
    \end{array}\right. \\
s \in \mathit{Application} & ::= &
\left\{\begin{array}{lr@{\hspace{1em}}l}
       k && \mbox{\em --- constant (numeric or $\NIL$)}\\
       (\CONS\,\, x_1\,\, x_2) && \mbox{\em --- constructor} \\ 
       (\CAR\,\, x) &  (\CDR\,\, x) & \mbox{\em --- selectors} \\ 
       (\NULLQ\,\, x) & (\PRIM\,\, x_1\,\, x_2) & \mbox{\em ---  tester and generic arithmetic} \\ 
%        (\NULLQ\,\, x) && \mbox{\em ---  tester} \\ 
       (\ID\,\, x) && \mbox{\em ---  identity function (for inlining)} \\ 
%        (\PRIM\,\, x_1\,\, x_2) && \mbox{\em --- generic arithmetic} \\ 
       \multicolumn{2}{l}{(f\,\, x_1\,\,\ldots\,\, x_n)} 
            & \mbox{\em --- function application} 
    \end{array}\right.
\end{eqnarray*}
  \caption{The syntax of our language}\label{fig:lang-syntax}
\figrule
\normalsize
\end{figure}


\subsubsection{Semantics}
We now give  a small-step semantics for our  language.  We shall later
augment this semantics so that it enables us to reason about liveness.
We start with the domains used by the semantics:
\[
\begin{array}{rlcl@{\hspace{2em}}l}
\rho: & \mathit{Env} &=&\mathit{Var} \rightarrow \mathit{Loc} & \mbox{-- Environment} \\ 
v:   & \mathit{Val} &=& \mathbb{N} + \{\NIL\} + \mathit{Data \times
  Data}& \mbox{-- Values}\\
c:   & \mathit{Clo} &=& \mathit{(Exp \times Env)}& \mbox{--
  Closures}\\
d: & \mathit{Data} &=&\mathit{Val} + \mathit{Clo} & \mbox{-- Values and Closures} \\ 
\heap: & \mathit{Heap} & =&\mathit{Loc} \rightarrow Data & \mbox{-- Heap}
\end{array}
\]

Here $\mathit{Loc}$ is a countable set  of locations in the heap.  Since
all data objects are boxed, we  model an environment as a mapping from
the set of variables of the program $\mathit{Var}$ to locations in the
heap.  These either contain a value  in WHNF (a number, the empty list
$\NIL$, or  a \CONS\ cell with possibly unevaluated constituents)
or a {\em closure}.   A closure is a pair $(s, \rho)$  in which $s$ is
an  unevaluated application  with  the values  of  its free  variables
given by $\rho$.

The semantics of expressions (and similarly applications) are given by
the  judgement form $\rho,  \stk, \heap,  e \rightarrow  \rho', \stk',
\heap', e'$.  Here \stk\ is a stack of continuation frames represented
as  a list  in the  description of  the semantics.   Each continuation
frame  is of the  form $(\rho,  x, e)$  where the  location of  $x$ is
updated when the expression  that is currently being evaluated reaches
WHNF,  and  $e$  is  the  next  expression  to  be  evaluated  in  the
environment  $\rho$.   The  start  state is  $(\{\},[(\{\},  \mainpgm,
  \HALT)], \{\}, e_\mainpgm)$, and the program terminates successfully
on  reaching   the  halt   state  $(\rho,[\,],  \heap,   \HALT)$  with
$\rho(\mainpgm)$  containing  the final  result.  Note  that since  we
assume that our language is not statically typed, a program with other
than syntactic errors (including those that could have been eliminated
using a  static type system) lead  to {\em stuck  states} i.e.  states
not covered by any rules in the small-step semantics.

The  notation $[\myvec{x} \mapsto  \myvec{\ell}]$ represents
an  environment that maps  variables $x_1,  \ldots, x_n$  to locations
$\ell_1,  \ldots,  \ell_n$.   The  notation  $\heap[\ell  \mapsto  d]$
indicates the  updation of  a heap \heap\  at $\ell$ with  $d$.  $\rho
\oplus \rho'$  represents the  environment $\rho$ shadowed  by $\rho'$
and $\lfloor \rho \rfloor_X$  represents the environment restricted to
the locations in $X$. Finally $FV(s)$ represents the free variables in
the application $s$.

As an example, consider the rules related to the application $(+~x~y)$
involving a strict binary operator.  When both $x$ and $y$ are already
in WHNF  ({\sc prim-whnf}), the  heap is updated  with the sum  of the
arguments  and  the  continuation  gives  the next  expression  to  be
evaluated.   If  either  of  the   arguments  is  not  in  WHNF  ({\sc
  prim-1-clo} and {\sc prim-2-clo}), it  is sent for evaluation, and a
continuation marks that the evaluation  of $(+~x~y)$ has to be resumed
after the argument is evaluated.

\begin{figure}[t!]
\begin{tabular}{|c|c|c|}

\hline
Premise & Transition & Rule name \\
\hline
\hline
          & $\rho, (\rho', x, e)\!:\!S, H, \kappa
  \rightsquigarrow \rho', S, H[\rho'(x) \mapsto \kappa], e$    &  \sc{const} \\
\hline
          & \shortstack[c]{$\rho, (\rho', z, e)\!:\!S, H, (\CONS~x~y)  \rightsquigarrow
$ \\  $\rho', S, H[z \mapsto (H(\rho(x)),H(\rho(y)))], e$}     &  \sc{cons} \\
\hline
$H(\rho(x)) \mbox{ is } (d_1, d_2)$ & $\rho, (\rho', z, e)\!:\!S, H,
(\CAR~x)  \rightsquigarrow \rho', S, H[\rho(z) \mapsto d_1], e$      &  \sc{car-whnf} \\
\hline
$H(\rho(x)) \mbox{ is } (e, \rho')$ & $\rho, S, H, (\CAR~x)  \rightsquigarrow
\rho'\oplus\rho, (\rho, x, (\CAR~x))\!:\!S, H, e$      &  \sc{car-clo} \\
\hline
$H(\rho(x)), H(\rho(y)) \in \mathbb{N}$
 & \shortstack[c]{$\rho, (\rho', z, e)\!:\!S, H, (+~x~y)  \rightsquigarrow$ \\
$\rho', S, H[\rho(z) \mapsto H(\rho(x)) + H(\rho(y))], e$}      &  \sc{prim-whnf} \\
\hline
$H(\rho(x)) \mbox{ is } (s, \rho')$ & $\rho, S, H, (+~x~y)  \rightsquigarrow
\rho'\oplus\rho, (\rho, x, (+~x~y))\!:\!S, H, e$      &  \sc{prim-1-clo} \\
\hline
$H(\rho(y)) \mbox{ is } (s, \rho')$ & $\rho, S, H, (+~x~y)  \rightsquigarrow
\rho'\oplus\rho, (\rho, x, (+~x~y))\!:\!S, H, e$      &  \sc{prim-2-clo} \\
\hline
\shortstack[c]{$\mathit{f}~\mbox{defined as}$ \\ $~(\DEFINE~(f~\myvec{y})~e_{\mathit{f}})$}  & $\rho, S, H, (f~\myvec{x})  \rightsquigarrow
[\myvec{y} \mapsto \rho(\myvec{x})], S, H, e_{\mathit{f}}$      &  \sc{funcall} \\
\hline
$\ell$ is a new location& \shortstack[c]{$\rho, S, H, (\LET~x\leftarrow s~\IN~e)
  \rightsquigarrow$ \\
$[x \mapsto \ell]\oplus\rho, S, H[\ell \mapsto (s, (x \mapsto
  \ell)\oplus\lfloor \rho\rfloor_{FV(S)\setminus\{x\}})], e$} & \sc{let} \\ 
\hline
$H(\rho(x)) \ne 0$ & $\rho, S, H, (\SIF~x~e_1~e_2)   \rightsquigarrow
\rho, S, H,  e_1$ & \sc{if-true} \\ 
\hline
$H(\rho(x)) = 0$ & $\rho, S, H, (\SIF~x~e_1~e_2)   \rightsquigarrow
\rho, S, H,  e_2$ & \sc{if-false} \\ 
\hline
$H(\rho(x)) = (e,\rho')$ & \shortstack[c]{$\rho, S, H,
  (\SIF~x~e_1~e_2)   \rightsquigarrow$ \\ 
$\rho'\oplus\rho, (\rho, x, (\IF~x~e_1~e_2))\!:\!S, H,  e$} & \sc{if-clo} \\ 
\hline
\shortstack[c]{$H(\rho(x))~\mbox{is}$ \\$\mbox{whnf with value}~v$}& $\rho, (\rho', z, e)\!:\!S, H,
(\RETURN~x)  \rightsquigarrow \rho', S, H[\rho(z) \mapsto v], e$ & \sc{return-whnf}\\   
\hline
$H(\rho(x)) = (e,\rho')$ & \shortstack[c]{$\rho, S, H, (\RETURN~x)
  \rightsquigarrow$ \\
$\rho'\oplus\rho,~ (\rho, x, (\RETURN~x))\!:\!S, H,  e$} & \sc{return-clo} \\
\hline
\end{tabular}
\caption{A small-step semantics for the language}\label{fig:lang-semantics}
\end{figure}
%==============================================================
\renewcommand{\pp}[2]{\ensuremath{#1\!\!:\!#2}} % prog point

>>>>>>> 4bb03a5c3d7b9f8e48b056d77b2ef7801e7effa3


We  consider  two  ways  to  reduce the  memory  requirement  of  lazy
functional  programming  languages. The  first  is  to modify  garbage
collectors  to  preserve  only  {\em  live} data---a  subset  of  {\em
reachable data}.  This results in an increase in the garbage reclaimed
and  consequently in  fewer  garbage collections.   The  second is  to
eagerly evaluate closures  that are guaranteed to be  evaluated in the
future.  

The  main contribution  of  this  paper is  an  uniform framework  for
obtaining the information for the optimizations mentioned above---{\em
liveness}  and {\em strictness}  analysis. Using  a central  notion of
demand,  we  formulate   a  context-sensitive  liveness  analysis  for
structured  data and  prove  it  correct.  We  then present strictness
as a dual of liveness. We use a  0-CFA-like
conservative   approximation   to   annotate   each   allocation   and
function-call program point  with a finite-state automaton---which the
garbage-collector inspects to  curtail reachability during
marking. The result of the strictness analysis, being necessarily
finite,  can  be directly used to insert code to evaluate closures. 

%As a result,  fewer objects are marked (albeit  with a more expensive
%marker) and then preserved (e.g.\ by a copy phase).

Experiments  confirm  the  expected  performance benefits.  The  early
evaluation   of   closures  decreases   the   memory   demands  of   a
program. Further,  liveness-based collection results in  a increase in
garbage  reclaimed  and  a   consequent  decrease  in  the  number  of
collections, a decrease  in the memory size required  to run programs,
and  reduced  overall  garbage  collection  time  for  a  majority  of
programs.

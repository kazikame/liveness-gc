
The memory  requirement of a lazy functional  programming language can
be decreased  in two ways. The  first is to  use the result of  a {\em
liveness  analysis} during  garbage collection  to preserve  only {\em
live}  data---a  subset  of  {\em  reachable data}.  This  results  in
collection of greater amount of garbage and consequently fewer garbage
collections. Apart from evaluated data this will also results in early
release  of memory  hogging closures.   The second  way is  to eagerly
evaluate closures that  are guaranteed to be evaluated  in the future.
The information that is required  for this eager evaluation comes from
{\em strictness analysis}.

For  a first-order  lazy functional  language, we  present  an uniform
framework  for liveness  and strictness  ana   lysis. We  start by  for a
first-order functional  for language we  formulate a context-sensitive
liveness analysis for  structured data and prove it  correct.  We then
use   a  0-CFA-like  conservative   approximation  to   annotate  each
allocation  and  function-call   program  point  with  a  finite-state
automaton---which   the    garbage-collector   inspects   to   curtail
reachability  during marking. As  a result,  fewer objects  are marked
(albeit with a  more expensive marker) and then  preserved (e.g.\ by a
copy phase).

Experiments  confirm the  expected performance  benefits---increase in
garbage  reclaimed  and  a   consequent  decrease  in  the  number  of
collections, a decrease  in the memory size required  to run programs,
and  reduced  overall  garbage  collection  time  for  a  majority  of
programs.

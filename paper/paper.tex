<<<<<<< HEAD
\documentclass{sig-alternate}
=======
<<<<<<< HEAD
%------------------------------------------------------------%
\documentclass{llncs}
\pagestyle{plain}
\usepackage{longtable} 
%------------------------------------------------------------%
%- common stuff starts here....
>>>>>>> 56ee31a761282a98c71537e433148fc7a9d2dce0
\usepackage{etex}
\usepackage{float}
\usepackage{mathrsfs}
\usepackage{booktabs}
\usepackage{boxedminipage}
\usepackage[T1]{fontenc}
<<<<<<< HEAD
\usepackage[pdf]{pstricks}
=======
%\usepackage[pdf]{pstricks}
>>>>>>> 56ee31a761282a98c71537e433148fc7a9d2dce0
\usepackage{epsfig}
\usepackage{multirow}
\usepackage{url}
\usepackage[normalem]{ulem}
\usepackage{schemepgm}
\usepackage{graphicx}
\usepackage{graphpap}
\usepackage{tabularx}
<<<<<<< HEAD
=======
%\usepackage{esvect}
%\usepackage[libertine]{newtxmath}
%\usepackage{color}
%\usepackage{xcolor}
>>>>>>> 56ee31a761282a98c71537e433148fc7a9d2dce0
\usepackage{algorithmic}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{pstricks}
\usepackage{pst-text}
\usepackage{pst-node}
\usepackage{pst-tree}
\usepackage{pst-rel-points}
<<<<<<< HEAD
\usepackage{bcprules}
=======
%\usepackage{pst-all}
\usepackage{bcprules}
%\usepackage{subfigure}
%\usepackage{algorithmic}
%\usepackage{anysize}     
>>>>>>> 56ee31a761282a98c71537e433148fc7a9d2dce0
\input{fh_defs}
\def\drawplusplus#1#2#3{\hbox to 0pt{\hbox to #1{\hfill\vrule height #3 depth
      0pt width #2\hfill\vrule height #3 depth 0pt width #2\hfill
      }}\vbox to #3{\vfill\hrule height #2 depth 0pt width
      #1 \vfill}}
      %Poor man's typography
\def\concat{\mathrel{\drawplusplus {12pt}{0.4pt}{5pt}}}
      %It would be better to specify these in font-relative measures, but it 
      %probably doesn't scale anyway.
%\newcommand{\comment}[1]{}
\definecolor{Myblue}{rgb}{0.0,0.0,0.5}
\newcommand{\comment}[1]{{\color{Myblue}{\medskip \hrule\medskip
    #1 \medskip \hrule \medskip}}}
\newcommand{\scmin} {\mbox{\sf\em in}}
\newcommand{\scmnull}{\mbox{\sf\em null?}}
\newcommand{\scmpair}{\mbox{\sf\em pair?}}
\newcommand{\scmprim}{\ensuremath{\mathsf{+}}}
\newcommand{\sh}[1]{{\colorbox{gray!20}{\framebox{$#1$}}}}
<<<<<<< HEAD
%\nonstopmode
=======
\nonstopmode
>>>>>>> 56ee31a761282a98c71537e433148fc7a9d2dce0
\def\myvec{\mathaccent"017E } % wretched springer mode redefines \vec as bold!
\newcommand{\stk}{\mbox{S}}       % stack
\newcommand{\ID}{\mbox{$\mathbf{ id}$}} % identity function
\newcommand{\bang}{\mbox{\sc bang}}
 
\begin{document}
<<<<<<< HEAD
%
% --- Author Metadata here ---
\conferenceinfo{WOODSTOCK}{'97 El Paso, Texas USA}
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{Liveness-Based Garbage Collection for Lazy Languages}

%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\numberofauthors{3} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
% 1st. author
\alignauthor K. Prasanna Kumar \\
       \affaddr{IIT Bombay,}\\
       \affaddr{Mumbai 400076, India}
       \email{prasanna@cse.iitb.ac.in}
% 2nd. author
\alignauthor Amey Karkare\\
       \affaddr{IIT Kanpur}\\
       \affaddr{Kanpur 208016, India}
       \email{karkare@cse.iitk.ac.in}
% 3rd. author
\alignauthor Amitabha Sanyal \\
       \affaddr{IIT Bombay}\\
       \affaddr{Mumbai 400076, India}\\
       \email{as@cse.iitb.ac.in}
}
\maketitle
\begin{abstract}
We  consider  two  ways  to  reduce the  memory  requirement  of  lazy
functional  programming  languages. The  first  is  to modify  garbage
collectors  to  preserve  only  {\em  live} data---a  subset  of  {\em
reachable data}.  This results in an increase in the garbage reclaimed
and  consequently in  fewer  garbage collections.   The  second is  to
eagerly evaluate closures  that are guaranteed to be  evaluated in the
future.  

The  main contribution  of  this  paper is  an  uniform framework  for
obtaining the information for the optimizations mentioned above---{\em
liveness}  and {\em strictness}  analysis. Using  a central  notion of
demand,  we  formulate   a  context-sensitive  liveness  analysis  for
structured  data and  prove  it  correct.  We  then present strictness
as a dual of liveness. We use a  0-CFA-like
conservative   approximation   to   annotate   each   allocation   and
function-call program point  with a finite-state automaton---which the
garbage-collector inspects to  curtail reachability during
marking. The result of the strictness analysis, being necessarily
finite,  can  be directly used to insert code to evaluate closures. 

%As a result,  fewer objects are marked (albeit  with a more expensive
%marker) and then preserved (e.g.\ by a copy phase).

Experiments  confirm  the  expected  performance benefits.  The  early
evaluation   of   closures  decreases   the   memory   demands  of   a
program. Further,  liveness-based collection results in  a increase in
garbage  reclaimed  and  a   consequent  decrease  in  the  number  of
collections, a decrease  in the memory size required  to run programs,
and  reduced  overall  garbage  collection  time  for  a  majority  of
programs.
\end{abstract}

% A category with the (minimum) three required fields
\category{H.4}{Information Systems Applications}{Miscellaneous}
%A category including the fourth, optional field follows...
\category{D.2.8}{Software  Engineering}{Metrics}[complexity  measures,
  performance measures]

\terms{Theory}

\keywords{ACM proceedings, \LaTeX, text tagging}

By Friday, February 27 2015, 23:59 (UTC-11), submit a full paper of at
most  12 pages (6  pages for  an Experience  Report), in  standard ACM
conference format, including bibliography, figures, and appendices.

\section{Introduction}
\label{sec:intro}

Functional  programming  languages  depend  on  garbage  collector  to
efficiently  reclaim  unused  memory   allocated  by  programs  either
explicitly (for example using constructors) or implicitly (for example
for      closures).       However,      empirical      studies      on
Haskell~\cite{rojemo96lag},  Scheme~\cite{karkare06effectiveness}  and
Java~\cite{shaham02estimating}  programs   have  shown   that  garbage
collectors leave uncollected a lot of memory objects that are not live
(here {\em live}ness  means the object can potentially be  used by the
program at  a later  stage).  Due  to lack of  a suitable  analysis to
distinguish  reachable  objects  from live  objects.  current  garbage
collectors conservatively approximate the  liveness of heap objects by
their reachability from a set of memory locations called the {\em root
  set\/} resulting in unnecessary memory usage.

Languages having lazy  semantics for evaluation put  further demand on
memory as they  require heap allocated closure to be  carried from the
point of occurrence  of an expression to the point  of (first) real use
of  that expression.  Strictness analysis~\cite{some-refs}  statically
determines  the  patterns  of  future usage  of  an  expression,  thus
allowing some  of the  closures to  be evaluated at  the point  of the
occurrence of the corresponding expression.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% MOTIVATING EXAMPLE
\newcommand{\nilfigure}
{\scalebox{0.75}{
\psset{unit=1mm,nodesep=0mm,labelsep=0.5mm}
\begin{pspicture}(0,0)(1,1)
%\psgrid[xunit=1cm,yunit=1cm,gridwidth=.2pt,subgridwidth=.1pt,subgriddiv=5,subgridcolor=gray,gridcolor=blue](0,0)(1,1)
\putnode{start}{origin}{0}{0}{}
\putnode{stop}{origin}{10}{10}{}
\ncline[offsetB=0,nodesepB=0,linewidth=.7]{-}{start}{stop} %here
\end{pspicture}
}}


\begin{figure*}[t!]
%%%%{\color{Myblue}
\begin{picture}(100,130)(0,-90)
%  \begin{center}
    \begin{tabular}{cc}
\begin{boxedminipage}{.5\textwidth}
      {\sf
	\renewcommand{\arraystretch}{1}{
	  \begin{uprogram}
	  \UFL\ \hspace*{-.31\TAL} (\DEFINE\ (\append\  \lista\ \listb)
	  \UNL{0}  (\SIF~(\NULLQ \ \lista)
	       \listb
	  \UNL{1}      (\CONS\ (\CAR\  \lista)
%          \UNL{2}          (\CAR\  \lista)
	  \UNL{2}\;\;\;\;\;          (\append\ (\CDR\  \lista)
          \listb))))
          \UNL{0}
	  \UNL{0} \hspace*{-.49\TAL} (\LET\ \pz  $\leftarrow$(\CONS\ (\CONS\ $4$ (\CONS\ $5$ \NIL))
	  \UNL{3}\ \ \ \  (\CONS\ $6$ \NIL)) \IN
	  \UNL{0} (\LET\ \py  $\leftarrow$ (\CONS\ $3$ \NIL) \IN
	  \UNL{1}   (\LET\ \pw $\leftarrow$ (\append\ \py\  \pz)\ \IN
	  \UNL{1}               $\,\,\,\,\,\,\,\,\pi$:(\CAR\ (\CDR\ \pw)))))
	\end{uprogram}
      }} 
\end{boxedminipage}
      &
      \raisebox{-25mm}{\scalebox{.75}{
	%%%%%%%%%%%%%%%%%%%%%Uday's stuff%%%%%%%%%%%%%%%%%%%%%%%%%
      \psset{unit=1mm}
      \psset{linewidth=.3mm}
      \begin{pspicture}(0,-5)(70,60)
	%\psframe(0,0)(73,60)
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\putnode{o}{origin}{13}{50}{\TwoCells{o1}{o2}}
	\putnode{a}{o}{-10}{-15}{\psframebox{3}}
%	\putnode{b}{o}{10}{-15}{\psframebox[linestyle=none,framesep=.5]{\NIL}}
	\ncline[offsetB=-.5,nodesepB=.1]{*->}{o1}{a}
	%\aput[-3.5](.5){\scalebox{1.2}{\psframebox[framesep=.2,linestyle=none,fillstyle=solid,
	%      fillcolor=white]{$\times$}}}
        \putnode{b}{o}{0}{-3}{\psframebox[linestyle=none,framesep=.5]{\scalebox{.63}{\nilfigure}}}
%	\ncline[offsetB=-.5,nodesepB=.1]{*->}{o2}{b}
	%\ncline[offsetB=-.5,nodesepB=.1]{->}{o2}{b}
	\putnode{y}{o}{-14}{8}{\psframebox[linestyle=none,framesep=.5]{y}}
	\nccurve[nodesepB=-.2,angleA=330,angleB=120]{->}{y}{o}
	\aput[-3.5](.5){\scalebox{1.2}{\psframebox[framesep=.2,linestyle=none,fillstyle=solid,
		  fillcolor=white]{$\times$}}}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\putnode{c}{o}{25}{0}{\TwoCells{c1}{c2}}
	\putnode{d}{c}{10}{-10}{\TwoCells{d1}{d2}}
	\putnode{e}{d}{-13}{-12}{\TwoCells{e1}{e2}}
	\putnode{f}{d}{13}{-12}{\TwoCells{f1}{f2}}
	\ncline[nodesepB=-.5]{*->}{c2}{d}
	\ncline[nodesepB=-.5,linewidth=.7]{->}{c2}{d}
	\nccurve[ncurv=1,angleA=270,angleB=330]{*->}{c1}{a}
	\aput[-3.5](.2){\scalebox{1.2}{\psframebox[framesep=.2,linestyle=none,fillstyle=solid,
	      fillcolor=white]{$\times$}}}
	\nccurve[nodesepB=-.5,angleA=240,angleB=70]{*->}{d1}{e}
	\nccurve[nodesepB=-.5,angleA=240,angleB=70,linewidth=.7]{->}{d1}{e}
	\nccurve[nodesepB=-.5,angleA=300,angleB=110]{*->}{d2}{f}
	\aput[-3.5](.5){\scalebox{1.2}{\psframebox[framesep=.2,linestyle=none,fillstyle=solid,
	      fillcolor=white]{$\times$}}}
	\putnode{w}{c}{-8}{8}{\psframebox[linestyle=none,framesep=.2]{w}}
	\putnode{ww}{c}{15}{8}{\psframebox[linestyle=none,framesep=.2]{z}}
	\nccurve[nodesepB=-.2,angleA=330,angleB=120,linewidth=.7]{->}{w}{c}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\putnode{g}{e}{-8}{-12}{\psframebox{4}}
	\putnode{h}{e}{8}{-14}{\TwoCells{h1}{h2}}
	\putnode{i}{f}{-8}{-11}{\psframebox{6}}
%	\putnode{j}{f}{8}{-11}{\psframebox[linestyle=none,framesep=.5]{\NIL}}
	\ncline[offsetB=-.5,nodesepB=.1]{*-}{e1}{e1}
	\ncline[linestyle=dashed,offsetB=-.5,nodesepB=.1,linewidth=.7]{->}{e1}{g}
        %here
        \putnode{j1}{f}{0}{-3}{\psframebox[linestyle=none,framesep=0]{\scalebox{.63}{\nilfigure}}}
        \putnode{j2}{h}{0}{-3}{\psframebox[linestyle=none,framesep=.5]{\scalebox{.63}{\nilfigure}}}

%        \aput[-3.2](.6){\scalebox{1.2}{\psframebox[framesep=.1,linestyle=none,fillstyle=solid,
%	      fillcolor=white]{$\times$}}} %and here
	\ncline[offsetB=-.5,nodesepB=-.3]{*-}{e2}{e2}
	\ncline[linestyle=dashed,offsetB=-.5,nodesepB=.1,linewidth=.7]{->}{e2}{h} 
%	\aput[-3.2](.5){\scalebox{1.2}{\psframebox[framesep=.1,linestyle=none,fillstyle=solid,
%	      fillcolor=white]{$\times$}}} %and here

	\ncline[offsetB=-.5,nodesepB=.1]{*->}{f1}{i}
	\ncline[offsetB=-.5,nodesepB=.1]{*->}{f2}{j}
	\nccurve[nodesepB=-.2,angleA=270,angleB=90]{->}{ww}{d}
	\aput[-3.2](.4){\scalebox{1.2}{\psframebox[framesep=.1,linestyle=none,fillstyle=solid,
	      fillcolor=white]{$\times$}}}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\putnode{k}{h}{-8}{-11}{\psframebox{5}}
%	\putnode{l}{h}{8}{-11}{\psframebox[linestyle=none,framesep=.5]{\NIL}}
	\ncline[offsetB=-.5,nodesepB=.1]{*-}{h1}{h1}
	\ncline[linestyle=dashed,offsetB=-.5,nodesepB=.1,linewidth=.7]{->}{h1}{k}
%	\ncline[offsetB=-.5,nodesepB=.1]{*->}{h2}{l}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      \end{pspicture}}} \\
      (a) Example program.&
      \renewcommand{\arraystretch}{.9}{\begin{tabular}[t]{ll}
	(b) Memory graph at $\pi$. Thick edges denote \\
        {\white (b) }live links. Traversal stops at edges marked\\
        {\white (b) }$\times$  during garbage collection.
      \end{tabular}}
    \end{tabular}
\end{picture}

\kern -3ex

\caption{Example Program and its Memory Graph.}\label{fig:mot-example}    
%  \end{center}
%%%%}\color{Myblue} end
\end{figure*}
We propose the  use of liveness analysis of heap  cells and strictness
analysis  of expressions  to  reduce the  memory  requirement of  lazy
functional  programming languages.   We modify  garbage collectors  to
preserve  only {\em  live} data---a  subset of  {\em reachable  data}.
This results in an increase  in the garbage reclaimed and consequently
in fewer  garbage collections.  Further, we eagerly evaluate closures
that are guaranteed to be evaluated in the future (strict closures).

The main contribution  of this paper is an uniform  framework for {\em
  liveness} and {\em strictness}  analysis to enable the optimizations
mentioned  above. Using  a central  notion of  demand, we  formulate a
context-sensitive liveness  analysis for structured data  and prove it
correct.  We then  present strictness as a dual of  liveness. We use a
0-CFA-like conservative approximation to  annotate each allocation and
function-call program point with  a finite-state automaton---which the
garbage-collector inspects to curtail reachability during marking. The
result of  the strictness analysis,  being necessarily finite,  can be
directly used to insert code to evaluate closures.

We previously proposed an interprocedural liveness analysis to improve
garbage collection first order eager subset of Scheme~\cite{cc-paper}.
The current paper extends the work to handle lazy evaluation semantics
for the same language.

Experiments  confirm  the  expected  performance benefits.  The  early
evaluation   of   closures  decreases   the   memory   demands  of   a
program. Further,  liveness-based collection results in  a increase in
garbage  reclaimed  and  a   consequent  decrease  in  the  number  of
collections, a decrease  in the memory size required  to run programs,
and  reduced  overall  garbage  collection  time  for  a  majority  of
programs.



%------------------------------------------------------------%
\subsubsection{Motivating Example}
\label{sec:motiv}

Figure~\ref{fig:mot-example}(a) shows  an example program.   The label
$\pi$ of an expression $e$  denotes a program point.  During execution
of  the program, it  represents the  instant of  time just  before the
evaluation  of  $e$.  
We  view the  heap  as a graph.  
Nodes in the heap, also  called  ($\CONS$) {\em  cells\/} contain $\CAR$ and $\CDR$ {\em fields}
containing values.  Edges in the graph are {\em references} and
emanate from {\em variables} or fields.
Variable and field values may also be atomic values ($\NIL$, integers etc.)
While it is convenient to box these in diagrams, our presented
analysis treats them as non-heap values.

Figure~\ref{fig:mot-example}(b)  shows the heap at $\pi$.
The edges shown  by thick arrows are those  which are made live by the
program. In addition,  assuming that
the value of any reachable part of the program result may be explored
or printed, the edges marked by thick dashed arrows are also live.
A cell  is  marked and preserved  during  garbage collection,  only  if it  is
reachable from the  root set through a path of  live edges.  All other
cells can be  reclaimed.  Thus if  a garbage collection takes
% place   at    the   time   represented   by   the    heap   shown   in
at $\pi$ with the    heap   shown   in
Figure~\ref{fig:mot-example}(b), only the cells $\pw$ and $(\CDR~ \pw)$, along with $(\CAR~(\CDR~\pw))$ and all cells reachable from it,
will be marked and preserved.






\subsubsection{Organization of the paper}
Section~\ref{sec:defs} gives
the syntax and semantics of
the language used to illustrate our analysis along with basic concepts
and    notations.
% Section~\ref{sec:operational}   describes    the
% operational semantics  of the  language.
Liveness analysis is described in
Section~\ref{sec:liveness} followed by a sketch of a correctness
proof relative to a non-standard semantics.
Section~\ref{sec:computing} shows how to encode liveness as
finite-state automata.
Section~\ref{sec:experiments}   reports   experimental   results and
Section~\ref{sec:lgc-always-better} proves that a liveness based
collector can never do more garbage collections than a reachability
based collector. 
% and Section~\ref{sec:conclusion} concludes the paper.

\section{The target language---syntax and semantics}
\label{sec:defs}
We let $x$, $y$, $z$ range over variables, $f$ over user-functions and
$p$    over    primitive    functions   ($\CONS$,    $\PRIM$    etc.).
Figure~\ref{fig:lang-syntax} describes the  syntax of our language. It
is a first  order language with lazy semantics  and restricts programs
to        be        in        Administrative        Normal        Form
(ANF)~\cite{chakravarty03perspective}  where all actual  parameters to
functions   are   variables.   This   restriction   does  not   affect
expressibility  (and we ignore  it in  examples when  inessential). In
addition, this  form also explicates the creation  of closures through
$\LET$s which are lazy.  A consequence  of lazy $\LET$ is that $x$ can
also occur  in $s$  in $\LET\,\, x  \leftarrow s\,\, \IN\,\,  e$. This
enables  creation of  graph-like structures  in a  pure  language. The
restriction of \LET\ to a single definition is for ease of exposition;
generalization  to  multiple  definitions  does  not  pose  conceptual
difficulties.  We  further restrict each  variable in a program  to be
distinct, so  that no scope shadowing  occurs---this simplifies proofs
of soundness.  The $\RETURN$  and \SIF\ expressions trigger evaluation
of  closures.

The body of the program is the expression denoted by $e_\mainpgm$; for
analysis purposes it is convenient to regard $e_\mainpgm$ as part of a
function definition $(\DEFINE\ ({\tt main})\ e_\mainpgm)$ as in C\@.
We write  $\pi\!:\!e$ to  associate the label  $\pi$ (not part  of the
language syntax) with the program point just before expression $e$.

% \paragraph{Inlining.}
{\color{Myblue}In spite of the ANF  restrictions it is still possible to
  inline non-recursive functions (a fact we use to prove the safety of
  liveness  analysis).  A user-function  call $(\LET\,\,  x \leftarrow
  (f\,y_1\,\ldots\,y_n) \,\, \IN\,\, e)$  to a function defined (after
  renaming  its  formals  and  locals  to be  disjoint  from  existing
  variables) by $(\DEFINE\ (f\ z_1\ \ldots\ z_n)\ e_f)$ is replaced by
  a  sequence of  $\LET$'s  of the  form $z_i\leftarrow  (\ID\,\,y_i)$
  followed by the body $e_f$ but with its $(\RETURN\,\,w)$ expressions
  replaced by $(\LET\,\, x \leftarrow (\ID\,\, w) \,\, \IN\,\, e)$.}

\begin{figure*}[]
\footnotesize
\begin{eqnarray*}
   p \in \mathit{Prog} & ::= & d_1 \ldots d_n \,\, e_\mainpgm
    \hspace{7em} \mbox{\em --- program}\\
    d \in Fdef & ::= & (\DEFINE\,\, (f\,\, x_1 \,\, \ldots \,\,x_n)\,\,
    e) 
    \hspace{1.7em} \mbox{\em --- function definition} \\
e \in \mathit{Expr} & ::= &
\left\{\begin{array}{ll@{\hspace{4em}}l}
       (\SIF\,\, x\,\, e_1\,\, e_2) && \mbox{\em --- conditional} \\ 
       (\LET\,\, x \leftarrow s\,\, \IN\,\, e) && \mbox{\em --- let binding} \\
       (\RETURN\,\, x) && \mbox{\em --- return from function}
    \end{array}\right. \\
s \in \mathit{Application} & ::= &
\left\{\begin{array}{lr@{\hspace{1em}}l}
       k && \mbox{\em --- constant (numeric or $\NIL$)}\\
       (\CONS\,\, x_1\,\, x_2) && \mbox{\em --- constructor} \\ 
       (\CAR\,\, x) &  (\CDR\,\, x) & \mbox{\em --- selectors} \\ 
       (\NULLQ\,\, x) & (\PRIM\,\, x_1\,\, x_2) & \mbox{\em ---  tester and generic arithmetic} \\ 
%        (\NULLQ\,\, x) && \mbox{\em ---  tester} \\ 
       (\ID\,\, x) && \mbox{\em ---  identity function (for inlining)} \\ 
%        (\PRIM\,\, x_1\,\, x_2) && \mbox{\em --- generic arithmetic} \\ 
       \multicolumn{2}{l}{(f\,\, x_1\,\,\ldots\,\, x_n)} 
            & \mbox{\em --- function application} 
    \end{array}\right.
\end{eqnarray*}
  \caption{The syntax of our language}\label{fig:lang-syntax}
\figrule
\normalsize
\end{figure*}


\subsubsection{Semantics}
We now give  a small-step semantics for our  language.  We shall later
augment this semantics so that it enables us to reason about liveness.
We start with the domains used by the semantics:
\[
\begin{array}{rlcl@{\hspace{2em}}l}
\rho: & \mathit{Env} &=&\mathit{Var} \rightarrow \mathit{Loc} & \mbox{-- Environment} \\ 
v:   & \mathit{Val} &=& \mathbb{N} + \{\NIL\} + \mathit{Data \times
  Data}& \mbox{-- Values}\\
c:   & \mathit{Clo} &=& \mathit{(Exp \times Env)}& \mbox{--
  Closures}\\
d: & \mathit{Data} &=&\mathit{Val} + \mathit{Clo} & \mbox{-- Values/Closures} \\ 
\heap: & \mathit{Heap} & =&\mathit{Loc} \rightarrow Data & \mbox{-- Heap}
\end{array}
\]

Here $\mathit{Loc}$ is a countable set  of locations in the heap.  Since
all data objects are boxed, we  model an environment as a mapping from
the set of variables of the program $\mathit{Var}$ to locations in the
heap.  These either contain a value  in WHNF (a number, the empty list
$\NIL$, or  a \CONS\ cell with possibly unevaluated constituents)
or a {\em closure}.   A closure is a pair $(s, \rho)$  in which $s$ is
an  unevaluated application  with  the values  of  its free  variables
given by $\rho$.

The semantics of expressions (and applications) are given by
the  judgment form $\rho,  \stk, \heap,  e \rightarrow  \rho', \stk',
\heap', e'$.  Here \stk\ is a stack of continuation frames represented
as  a list  in the  description of  the semantics.   Each continuation
frame  is of the  form $(\rho,  x, e)$,  where the  location of  $x$ is
updated when the currently evaluated expression reaches
WHNF,  and  $e$  is  the  next  expression  to  be  evaluated  in  the
environment  $\rho$.   The  start  state is  $(\{\},[(\{\},  \mainpgm,
  \HALT)], \{\}, e_\mainpgm)$, and the program terminates successfully
on  reaching   the  halt   state  $(\rho,[\,],  \heap,   \HALT)$  with
$\rho(\mainpgm)$  containing  the final  result.  Note  that since  we
assume that our language is not statically typed, a program with other
than syntactic errors (including those that could have been eliminated
using a  static type system) lead  to {\em stuck  states} i.e.  states
not covered by any rules in the small-step semantics.

The  notation $[\myvec{x} \mapsto  \myvec{\ell}]$ represents
an  environment that maps  variables $x_1,  \ldots, x_n$  to locations
$\ell_1,  \ldots,  \ell_n$.   The  notation  $\heap[\ell  \mapsto  d]$
indicates the  updation of  a heap \heap\  at $\ell$ with  $d$.  $\rho
\oplus \rho'$  represents the  environment $\rho$ shadowed  by $\rho'$
and $\lfloor \rho \rfloor_X$  represents the environment restricted to
the locations in $X$. Finally $FV(s)$ represents the free variables in
the application $s$.

As an example, consider the rules related to the application $(+~x~y)$
involving a strict binary operator.  When both $x$ and $y$ are already
in WHNF  ({\sc prim-whnf}), the  heap is updated  with the sum  of the
arguments  and  the  continuation  gives  the next  expression  to  be
evaluated.   If  either  of  the   arguments  is  not  in  WHNF  ({\sc
  prim-1-clo} and {\sc prim-2-clo}), it  is sent for evaluation, and a
continuation marks that the evaluation  of $(+~x~y)$ has to be resumed
after the argument is evaluated.


\begin{figure*}[t!]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Premise & Transition & Rule name \\
\hline
\hline
          & $\rho, (\rho', x, e)\!:\!S, H, \kappa
  \rightsquigarrow \rho', S, H[\rho'(x) \mapsto \kappa], e$    &  \sc{const} \\
\hline
          & \shortstack[c]{$\rho, (\rho', z, e)\!:\!S, H, (\CONS~x~y)  \rightsquigarrow
$ \\  $\rho', S, H[z \mapsto (H(\rho(x)),H(\rho(y)))], e$}     &  \sc{cons} \\
\hline
$H(\rho(x)) \mbox{ is } (d_1, d_2)$ & $\rho, (\rho', z, e)\!:\!S, H,
(\CAR~x)  \rightsquigarrow \rho', S, H[\rho(z) \mapsto d_1], e$      &  \sc{car-whnf} \\
\hline
$H(\rho(x)) \mbox{ is } (e, \rho')$ & $\rho, S, H, (\CAR~x)  \rightsquigarrow
\rho'\oplus\rho, (\rho, x, (\CAR~x))\!:\!S, H, e$      &  \sc{car-clo} \\
\hline
$H(\rho(x)), H(\rho(y)) \in \mathbb{N}$
 & \shortstack[c]{$\rho, (\rho', z, e)\!:\!S, H, (+~x~y)  \rightsquigarrow$ \\
$\rho', S, H[\rho(z) \mapsto H(\rho(x)) + H(\rho(y))], e$}      &  \sc{prim-whnf} \\
\hline
$H(\rho(x)) \mbox{ is } (s, \rho')$ & $\rho, S, H, (+~x~y)  \rightsquigarrow
\rho'\oplus\rho, (\rho, x, (+~x~y))\!:\!S, H, e$      &  \sc{prim-1-clo} \\
\hline
$H(\rho(y)) \mbox{ is } (s, \rho')$ & $\rho, S, H, (+~x~y)  \rightsquigarrow
\rho'\oplus\rho, (\rho, x, (+~x~y))\!:\!S, H, e$      &  \sc{prim-2-clo} \\
\hline
\shortstack[c]{$\mathit{f}~\mbox{defined as}$ \\ $~(\DEFINE~(f~\myvec{y})~e_{\mathit{f}})$}  & $\rho, S, H, (f~\myvec{x})  \rightsquigarrow
[\myvec{y} \mapsto \rho(\myvec{x})], S, H, e_{\mathit{f}}$      &  \sc{funcall} \\
\hline
$\ell$ is a new location& \shortstack[c]{$\rho, S, H, (\LET~x\leftarrow s~\IN~e)
  \rightsquigarrow$ \\
$[x \mapsto \ell]\oplus\rho, S, H[\ell \mapsto (s, (x \mapsto
  \ell)\oplus\lfloor \rho\rfloor_{FV(S)\setminus\{x\}})], e$} & \sc{let} \\ 
\hline
$H(\rho(x)) \ne 0$ & $\rho, S, H, (\SIF~x~e_1~e_2)   \rightsquigarrow
\rho, S, H,  e_1$ & \sc{if-true} \\ 
\hline
$H(\rho(x)) = 0$ & $\rho, S, H, (\SIF~x~e_1~e_2)   \rightsquigarrow
\rho, S, H,  e_2$ & \sc{if-false} \\ 
\hline
$H(\rho(x)) = (e,\rho')$ & \shortstack[c]{$\rho, S, H,
  (\SIF~x~e_1~e_2)   \rightsquigarrow$ \\ 
$\rho'\oplus\rho, (\rho, x, (\IF~x~e_1~e_2))\!:\!S, H,  e$} & \sc{if-clo} \\ 
\hline
\shortstack[c]{$H(\rho(x))~\mbox{is}$ \\$\mbox{whnf with value}~v$}& $\rho, (\rho', z, e)\!:\!S, H,
(\RETURN~x)  \rightsquigarrow \rho', S, H[\rho(z) \mapsto v], e$ & \sc{return-whnf}\\   
\hline
$H(\rho(x)) = (e,\rho')$ & \shortstack[c]{$\rho, S, H, (\RETURN~x)
  \rightsquigarrow$ \\
$\rho'\oplus\rho,~ (\rho, x, (\RETURN~x))\!:\!S, H,  e$} & \sc{return-coo} \\
\hline
\end{tabular}
\caption{A small-step semantics for the language}\label{fig:lang-semantics}
\end{center}
\end{figure*}


%==============================================================
\renewcommand{\pp}[2]{\ensuremath{#1\!\!:\!#2}} % prog point


\section{Liveness}\label{sec:liveness}

A variable is {\em live} it  there is a possibility of its value being
used  in future computation  and dead  if it  is definitely  not used.
Heap-allocated data needs a richer model of liveness which talks about
the liveness  of pointers including  fields of $\CONS$ cells.   We use
$\acar$, $\acdr$ to represent  access using $\CAR$, $\CDR$ fields. The
liveness of the structure reachable  from a variable is represented by
a  set  of  {\em   access  paths}  i.e.   prefix-closed  strings  from
$\{\acar,\acdr\}^\ast$.  As an example, if $x$ is a list with liveness
$\{\epsilon,  \acdr, \acdr\acar, \acdr\acdr,  \acdr\acdr\acar\}$, then
future computations can  only refer up to the  second and third members
of $x$.  The classical notions of a scalar variable being live or dead
correspond to $\{\epsilon\}$ and $\{\}$.

A {\em liveness environment} is a mapping from variables to subsets of
$\{\acar,\acdr\}^\ast$. But  we often express it as a  set, for
example writing $\{x.\acar\acdr, x.\acdr, y.\epsilon\}$ instead of $[x
  \mapsto\{\epsilon,\acar,\acar\acdr,\acdr\},     y\mapsto\{\epsilon\},
  z\mapsto\{\}]$.   For  eager  languages,  we  associate  a  liveness
environment  with each program  point; the  liveness at  program point
$\pi$ in $\pi:e$ is the liveness just before executing $e$. Due to the
inherent uncertainty  in determining the  point of evaluation  in lazy
languages, we  associate liveness  environments with certain  kinds of
paths in the program. All programs  points lying on the path share the
same liveness environment.  We explain this point later.
 
A complementary  notion to liveness  is {\em demand}.  The  demand for
expression  $e$   is  again  an   access  path---that  subset   of  of
$\{\acar,\acdr\}^\ast$ which  the context of $e$ may  explore of $e$'s
result.  So,  for example given  a demand $\sigma$ and  the expression
$\pi: (\RETURN\ x)$, the liveness at $\pi$ is exactly $x.\sigma$.  The
classical  analogy of  this  is  in {\em  strong  liveness}, where  an
assignment node $n: x:=y+z$ causes $y$  and $z$ to be live on entry to
$n$ if (and only if) $x$ is  live at exit of $n$---the liveness of $x$
at  exit from  $n$ becomes  the demand  on $y+z$.   

%% Note  that, for  an  operation  like division  which  may raise  an
%% exception,  the  assignment $n:  x:=y/z$  makes  $y$  and $z$  live
%% regardless of the liveness of $x$.

We use $\sigma$  to range over demands, $\alpha$  to range over access
paths  and $\Lv$  to range  over liveness  environments.  The notation
$\sigma_1\sigma_2$  denotes  the  set $\lbrace  \alpha_1\alpha_2  \mid
\alpha_1 \in  \sigma_1, \alpha_2 \in \sigma_2\rbrace$.  Often we shall
abuse notation to  juxtapose an edge label and a  set of access paths:
$\acar\sigma$   is   a   shorthand  for   $\lbrace\acar\rbrace\sigma$.
Finally,  we use $\Lfonly$  to range  over {\em  demand transformers}.
These transform demands on a function call into demands for its formal
parameters:    given    a    user    function    $f$,    defined    by
$(\DEFINE\  (f\ x_1\  \ldots\ x_n)\  \  e_f)$ and  called with  demand
$\sigma$, then $\Lf{f}{i}{\sigma}$ is the liveness of $x_i$ at $e_f$.

Note that liveness refers to  variables and fields, and not to $\CONS$
cells  (i.e.\  to  edges  in   the  memory  graph,  not  to  locations
themselves).   Hence liveness  of $\{x.\epsilon,x.\acar\}$  means that
future computation may refer to  the value $\ell$ of variable $x$, and
also to the $\CAR$ field of  location $\ell$.  In the absence of other
pointers to heap location $\ell$, we are certain that the $\CDR$ field
of  $\ell$  will  not  be   referenced  and  may  hence  be  corrupted
arbitrarily.   Note therefore,  that  while $\ell$  cannot be  garbage
collected, any location  $\ell'$ stored in the $\CDR$  field of $\ell$
would  be  garbage (again  provided  there  are  no other  aliases  to
$\ell$).

\bigskip
\hrule 
\bigskip

\subsection{Liveness Analysis}

To describe  the issues  in formulating liveness  of a  lazy language,
consider the function definition shown::

\renewcommand{\arraystretch}{1}{
	  \begin{uprogram}
	  \UNL{1} (\DEFINE\ (\pf~\pa)
	  \UNL{2}  $\pi_1\!\!:\, $(\LET\ \px\ $\leftarrow $\ (\CONS~1~\px) \IN
	  \UNL{3}      $\pi_2\!\!:\, $(\LET~\py\ $\leftarrow $\ (\CDR~\px) \IN  
          \UNL{4} \hspace*{.05cm}     $\pi_3\!\!:\,
          $(\LET\ \pz\  $\leftarrow$\   (\NULLQ~\pa) \IN
	  \UNL{5}  \hspace*{.05cm}    $\pi_4\!\!:\,
          $(\SIF\ $\pi_5\!\!:\,$ \pz\ ~$\pi_6\!\!:\,$ (\LET~\ww\  $\leftarrow$  (\take~5~\px) \IN
	  \UNL{6} \hspace*{1.15cm}    $\pi_7\!\!:\, $(\LET~\pu\  $\leftarrow$  (\CDR~\pw)  \IN
	  \UNL{7}  \hspace*{1.15cm}   $\pi_8\!\!:\,(\RETURN_1~\pu)$))
          \UNL{5} \hspace*{.05cm} $\pi_9\!\!:\, (\RETURN_2~\py)$)))))
	\end{uprogram}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Consider a call to $\pf$  with a demand $\sigma$. For obvious reasons,
this is also the demand on the return values $u$ and $y$, and thus the
liveness  at  the  program  points  $\pi_7$ and  $\pi_8$  re  $\lbrace
\pu.\sigma \rbrace$ and $\{\py.\sigma\}$.  The liveness at $\pi_7$ and
$\pi_8$ are propagated backwards as in traditional liveness analysis.

Since   \pu\  is  $(\CDR~   \pw)$,  the   liveness  of   $\sigma$  for
\pu\ translates  into a demand  of $\sigma$ on $(\CDR~\pw)$,  which in
turn generates  a liveness  of $\{\pw,~\pw.1\sigma\}$ at  $\pi_6$. The
liveness of  \pu\ is  also killed at  $\pi_6$ since  it is not  in the
scope of  \pu. However, for simplicity  of exposition, we  do not kill
the variable in our  formulation.  This does not introduce imprecision
since  the liveness  of  \pu\ will  not  be consulted  by the  garbage
collector at $\pi_6$.
%==============================================================
\begin{figure*}[t]  
\begin{eqnarray*}
\mathit{ref\/}(\kappa,\sigma,\Lfonly)
          &=& \{\,\} \mbox{, for $\kappa$ a constant, including $\NIL$}\\
\mathit{ref\/}((\CONS~x~y),\sigma,\Lfonly)
          &=& \{x.\alpha \mid \acar\alpha \in \sigma\} \cup \{y.\alpha \mid \acdr\alpha \in \sigma\} \\
\mathit{ref\/}((\CAR~x),\sigma,\Lfonly)
          &=&    \begin{array}{l l}
                    \{x.\epsilon\} \cup \{x.\acar\alpha \mid \alpha \in
\sigma\}, & \mbox{if}~\sigma \ne \emptyset\\
                    \emptyset  & \mbox{otherwise}
                 \end{array} \\
\mathit{ref\/}((\CDR~x),\sigma,\Lfonly)
          &=&    \begin{array}{l l}
                    \{x.\epsilon\} \cup \{x.\acdr\alpha \mid \alpha \in
\sigma\}, & \mbox{if}~\sigma \ne \emptyset\\
                    \emptyset  & \mbox{otherwise}
                 \end{array} \\
\mathit{ref\/}((\PRIM~x~y),\sigma,\Lfonly)
          &=&    \begin{array}{l l}
                    \{x.\epsilon, y.\epsilon\},  & \mbox{if}~\sigma \ne \emptyset\\
                    \emptyset  & \mbox{otherwise}
                 \end{array} \\
\mathit{ref\/}((\NULLQ~x),\sigma,\Lfonly)
          &=&    \begin{array}{l l}
                    \{x.\epsilon\},  & \mbox{if}~\sigma \ne \emptyset\\
                    \emptyset  & \mbox{otherwise}
                 \end{array} \\
\mathit{ref\/}((f~\myvec{x}),\sigma,\Lfonly)
%          &=& \bigcup_{i=1}^n y_i.\Lf{f}{i}{\sigma}
          &=&  \begin{array}{@{}l}  % to discourage \displaystyle
               \bigcup_{i=1}^n x_i.\Lf{f}{i}{\sigma}
               \end{array}
%          &=& \bigcup \{y_i.\Lf{f}{i}{\sigma} \mid i=1,\ldots, n\}
\\[1ex]
\mathcal{L}((\RETURN~x),\sigma,\Lfonly) &=& \{l \mapsto x.\sigma\}, \makebox[0mm]{\hspace*{3cm} where $l$ is a new label} \\
\mathcal{L}((\SIF~x~e_1~e_2),\sigma,\Lfonly) &=&
        \begin{array}{l l}
                    \mathcal{L}(e_1,\sigma,\Lfonly) \uplus
        \mathcal{L}(e_2,\sigma,\Lfonly) \uplus
        \{l \mapsto  \{x.\epsilon\}\},  & \mbox{if}~\sigma \ne \emptyset\\
        \emptyset  & \mbox{otherwise}
                 \end{array} \\
 \makebox[0mm]{\hspace*{3.8cm} where $l$ is a new label}\\
\mathcal{L}(\LET~x \leftarrow~s~\IN~e),\sigma,\Lfonly) &=&
        \{ l \mapsto \Ldonly_{x \leftarrow s}(\Lv(x)) \mid l \mapsto \Lv
        \in \mathcal{M}\}
\mbox{ where } \mathcal{M} = \mathcal{L}(e,\sigma,\Lfonly)\\
\Ldonly_{x \leftarrow s} &=& \Lfonly_f, \mbox{where}~f~\mbox{is a new function}\\
 \makebox[0mm]{\hspace*{7cm}   
 $(\DEFINE~(f\,x_1\,x_2\, \ldots \, x_n)~(\SIF\,*~x~s[(f\,x_1\,
           x_2\, \ldots\, x_n)/x]))$,} \\
 \makebox[0mm]{\hspace*{5.5cm} and 
     $(\ x_1\, \ldots\, x_n)$ are the variables in $s$}
\end{eqnarray*}
\begin{minipage}{0.85\textwidth}
\infrule[live-define]
        {\mathcal{L}(e_f,\sigma,\Lfonly) = 
           \bigcup_{i=1}^n z_i.\Lf{f}{i}{\sigma}
              \mbox{ for each $f$ and $\sigma$}
        }
        { d_1 \ldots d_k \len \Lfonly
\\ \makebox[0mm]{where
     $(\DEFINE\ (f\ z_1\ \ldots\ z_n)\ \ e_f)$ is a member of $d_1 \ldots d_k$}}
\end{minipage}
  \caption{Liveness equations and judgement rule}\label{fig:live-judge}
\end{figure*}
%======================================================================================
The liveness of lazy and eager evaluation differ in two respects:
\begin{enumerate}
\item  In an  eager  language, \pw\  would  not have  been live  after
  $\pi_6$, the point of its last use. In a lazy language, however, the
  definition  $\pu  \leftarrow  (\CDR~\pw)$,  does not  result  in  an
  evaluation  of  $(\CDR~\pw)$; instead  a  closure  is created.   The
  evaluation actually takes place while evaluating $(\RETURN~u)$. Thus
  it is necessary to record the liveness of $\pw$ at the program point
  $\pi_8$.

\item The second difference is that  our \LET s can be recursive as in
  program point $\pi_1$.  In such a case, the liveness of a let has to
  be formulated as a fix-point computation.
\end{enumerate}

  To address the first issue, we  regard the body of the function as a
  tree and consider paths from the root of this tree to program points
  which     trigger     a     evaluation---\SIF\    conditions     and
  \RETURN\  expressions. We call  such paths  {\em E-paths}.   For the
  program  shown, there  are three  such paths  $EP_1 =  \pi_1, \pi_2,
  \pi_3,  \pi_4, \pi_5$, $EP_1  = \pi_1,  \pi_2, \pi_3,  \pi_4, \pi_6,
  \pi_7, \pi_8$, and $EP_2 =  \pi_1, \pi_2, \pi_3, \pi_4, \pi_9$.  The
  analysis consists of two maps:  The map $\cal{M}$ maps a return path
  to a liveness  environment that is common to  all the program points
  in the path. And a second  map $\cal{P}$ maps a program point to the
  set of  return paths on  which the point  lies.  If a  program point
  happens  to fall  on  more than  one  such path,  then the  liveness
  environment of the  program point is the variable-wise  union of the
  liveness  environments  of the  individual  paths.   In the  example
  program,  ${\cal  M}(EP_1)=  \ldots$,  ${\cal  M}(EP_2)=\ldots$  and
  ${\cal M}(EP_3)= \ldots$.  Since  ${\cal P}(pi_4)$ is $\lbrace EP_1,
  EP_2, EP_3 \rbrace$, the liveness of $pi_4$ is \ldots.

  In  the  sequel we  shall  describe  how  to obtain  $\cal{M}$.  The
  formulation  of $\cal{P}$  is easy  and we  do not  describe  it any
  further.

\bigskip
\hrule 
\bigskip

First recall the classical formulation  of liveness (as sets of simple
variables)        on        three-address       instructions,        $
\mathit{live}_\mathit{in}(I) = \mathit{live}_\mathit{out}(I) \setminus
\mathit{def\/}(I) \cup  \mathit{ref\/}(I) $,  and then note  that {\em
  strong liveness}  needs, when $I$ is the  instruction $z:=x+y$, that
$\mathit{ref}(I)$     be     refined     to    $\{x,y\}$     if     $z
\in\mathit{live}_\mathit{out}(I)$ and $\{\}$ otherwise.

Our  liveness analysis  formulated  in Figure~\ref{fig:live-judge}  is
analogous.
% has three analogous aspects.
% \begin{itemize}
% \item
Firstly,  the function  $\mathit{ref}$,  when given  a statement  $s$,
returns the  incremental liveness {\em generated} by  $s$.  Because we
generalize  {\em  strong}  liveness,  $\mathit{ref}$  needs  a  second
parameter, specifying  the demand  $\sigma$ on the  result of  $s$, to
determine which access paths of its free variables are made live.  The
cases for $(\ID\ x)$ and $(\PRIM\ x\ y)$ exemplify this.
% The cases for
% $(\CAR\ x)$, $(\CAR\ x)$ and $(\CONS\ x\ y)$ show how demand for path $\alpha \in \sigma$
% is transformed into a deeper or shallower path in the demand for (or liveness of) $x$ or $y$.
% The   operator \PRIM\ dereferences its arguments  resulting in the liveness shown.
A demand  of  $\sigma$  on  (\CAR~$x$)  is  transformed  to  the  demand
$\acar\sigma$  on  $x$.   In  addition, \CAR\  always  dereferences  its
argument (even if its result is never used).
This generates the liveness  $\{x.\epsilon\} \cup  x.\acar\sigma$
(note $\sigma$ may be $\{\}$).
In the opposite  sense, the  demand  of $\acar\sigma$  on
(\CONS~$x$~$y$) is  transformed to the  demand $\sigma$ on  $x$.  Note
that \CONS\ does not, by itself, dereference its arguments.
Thirdly, for the case of a user-function call, a third parameter $\Lfonly$ to 
$\mathit{ref}$
expresses how the demand $\sigma$ on the result is transformed into demands on its parameters.
Constants generate no liveness.

The  function  $\mathcal{L}$ now  gives  the  (total)  liveness of  an
expression $e$.   The cases $\RETURN$ and  $\SIF$ are straightforward,
but note the liveness $x.\epsilon$  generated by the latter.  The case
$(\LET\   z\leftarrow   s\  \IN\   e')$   resembles  a   three-address
instruction:  the liveness  of $e$  is given  by taking  the liveness,
$\Lv$, of $e'$, killing any liveness of $z$ and adding any incremental
liveness from  $s$.  The main subtlety  is how the liveness  of $z$ in
$\Lv$  is converted  to a  demand  $\Lv(z)$ to  be placed  on $s$  via
$\mathit{ref}(s,\Lv(z),\Lfonly)$.

% \item
%%%%%%\marginpar{Say $\mathcal{L}$ is monotonic?}
Finally, the  judgement form $\mathit{Prog}  \len \Lfonly$ is  used to
determine  $\Lfonly$\@.   Analogously   to  classical  liveness  being
computed  as  a  solution  of  dataflow  equations,  we  require,  via
inference   rule  ({\sc  live-define}),   $\Lfonly$  to   satisfy  the
fixed-point property that:  when we assume $\Lfonly$ to  be the family
of demand transformers for the program then the calculated liveness of
each function  body $\mathcal{L}(e_f,\sigma,\Lfonly)$ agrees  with the
assumed $\Lfonly$.   As usual, there  are often multiple  solutions to
$\Lfonly$;  all are  safe (see  Section~\ref{sec:correctness})  but we
prefer  the  least  one  as  giving  the  least  liveness  subject  to
safety---and hence greatest amount of garbage collected.
% \end{itemize}

We make three observations: firstly the rule ({\sc live-define}) has a
least  solution  as  $\mathcal{L}(\cdot)$  is monotonic  in  $\sigma$;
secondly  that  ({\sc  live-define})   resembles  the  rule  for  type
inference of mutually recursive  function definitions, and thirdly the
asymmetry of  demand and liveness (compared to  post- and pre-liveness
classically) is due to the functional formulation here.

Section~\ref{sec:computing} shows how the demand transformers $\Lfonly$ for a program
(representing a fully context-sensitive analysis)
can be safely approximated, for each function, by a {\em procedure summary}
(unifying the contexts in the style of 0-CFA)\@.
The summary consists of a pair of a single demand and, for this demand,
the corresponding tuple of demands the function makes on its
arguments.

%\comment{



%}







% \item



\subsection{References}
\bibliography{fun_hra}{}
\bibliographystyle{abbrv}

Generated by bibtex from your ~.bib file.  Run latex,
then bibtex, then latex twice (to resolve references)
to create the ~.bbl file.  Insert that ~.bbl file into
the .tex source file and comment out
the command \texttt{{\char'134}thebibliography}.
% This next section command marks the start of
% Appendix B, and does not continue the present hierarchy
\section{More Help for the Hardy}
The sig-alternate.cls file itself is chock-full of succinct
and helpful comments.  If you consider yourself a moderately
experienced to expert user of \LaTeX, you may find reading
it useful but please remember not to change it.
%\balancecolumns % GM June 2007
% That's all folks!
\end{document}
=======
%  \title{Heap  Reference  Analysis  for Functional  Programs}
\title{Liveness-Based Garbage Collection}

% make a proper TOC despite llncs
\setcounter{tocdepth}{2}
\makeatletter
\renewcommand*\l@author[2]{}
\renewcommand*\l@title[2]{}
\makeatletter



  \author{K. Prasanna Kumar\inst{1} \and Amey Karkare\inst{2}
    \and   Amitabha Sanyal\inst{1}}
  \institute{IIT Bombay, Mumbai 400076, India\\
    \email{$\{$prasanna,as$\}$@cse.iitb.ac.in}, \and 
             IIT Kanpur, Kanpur 208016, India\\
    \email{karkare@cse.iitk.ac.in}}
\maketitle

\begin{abstract}
\input{sections/abstract}
\end{abstract}

%------------------------------------------------------------%


%% \begin{figure}
%% \tableofcontents       %%%%%%% BEWARE: find the \setcounter{page}{2}
%%                        %%%%%%% and comment it out when deleting this TOC.
%% \vspace{5cm}

%% \section*{Page Budget}
%% CC'2014 and ESOP'2014 have a limit of 20 pages.
%% A draft page budget is:
%% \begin{itemize}
%% \item 1. abstract/introduction (3 pages)
%% {\color{red}Currently 2.5 pages.}
%% \item 2. core language syntax and semantics (2 pages).
%% {\color{red}Currently 2 pages.}
%% \item 3. liveness analysis and correctness (3 pages)
%% {\color{red}Currently 3.8 pages.}
%% \item 4. practical liveness computation (6 pages)
%% {\color{red}Currently 6.2 pages.}
%% \\ I think this is where should do all 3 of: the context-insensitive analysis
%% (one which has a summary demand for each function), then the
%% solving like differential equations, then using Mohri-Nederhof to
%% get a NFA for each (call/cons) program point.
%% \item 5. experimental framework and results (4 pages)
%% \item 6. (optional) monotonicity of GC (0.5 page)---our technique can never
%% cause more collections.
%% \item 7. conclusions/acknowledgements/bibliography (1.5 page)
%% \end{itemize}
%% \end{figure}

\input{sections/intro}
\input{sections/syntax-and-semantics}
\input{sections/liveness}

%\input{sections/restOfOldPaper}
\bibliography{fun_hra}{}
\bibliographystyle{splncs}

\end{document}
=======
%------------------------------------------------------------%
\documentclass{llncs}
\pagestyle{plain}
\usepackage{longtable} 
%------------------------------------------------------------%
%- common stuff starts here....
\usepackage{etex}
\usepackage{float}
\usepackage{mathrsfs}
\usepackage{booktabs}
\usepackage{boxedminipage}
\usepackage[T1]{fontenc}
%\usepackage[pdf]{pstricks}
\usepackage{epsfig}
\usepackage{multirow}
\usepackage{url}
\usepackage[normalem]{ulem}
\usepackage{schemepgm}
\usepackage{graphicx}
\usepackage{graphpap}
\usepackage{tabularx}
%\usepackage{esvect}
%\usepackage[libertine]{newtxmath}
%\usepackage{color}
%\usepackage{xcolor}
\usepackage{algorithmic}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{pstricks}
\usepackage{pst-text}
\usepackage{pst-node}
\usepackage{pst-tree}
\usepackage{pst-rel-points}
%\usepackage{pst-all}
\usepackage{bcprules}
%\usepackage{subfigure}
%\usepackage{algorithmic}
%\usepackage{anysize}     
\input{fh_defs}
\def\drawplusplus#1#2#3{\hbox to 0pt{\hbox to #1{\hfill\vrule height #3 depth
      0pt width #2\hfill\vrule height #3 depth 0pt width #2\hfill
      }}\vbox to #3{\vfill\hrule height #2 depth 0pt width
      #1 \vfill}}
      %Poor man's typography
\def\concat{\mathrel{\drawplusplus {12pt}{0.4pt}{5pt}}}
      %It would be better to specify these in font-relative measures, but it 
      %probably doesn't scale anyway.
%\newcommand{\comment}[1]{}
\definecolor{Myblue}{rgb}{0.0,0.0,0.5}
\newcommand{\comment}[1]{{\color{Myblue}{\medskip \hrule\medskip
    #1 \medskip \hrule \medskip}}}
\newcommand{\scmin} {\mbox{\sf\em in}}
\newcommand{\scmnull}{\mbox{\sf\em null?}}
\newcommand{\scmpair}{\mbox{\sf\em pair?}}
\newcommand{\scmprim}{\ensuremath{\mathsf{+}}}
\newcommand{\sh}[1]{{\colorbox{gray!20}{\framebox{$#1$}}}}
%\nonstopmode
\def\myvec{\mathaccent"017E } % wretched springer mode redefines \vec as bold!
\newcommand{\stk}{\mbox{S}}       % stack
\newcommand{\ID}{\mbox{$\mathbf{ id}$}} % identity function
\newcommand{\bang}{\mbox{\sc bang}}
 
\begin{document}
%  \title{Heap  Reference  Analysis  for Functional  Programs}
\title{Liveness-Based Garbage Collection}

% make a proper TOC despite llncs
\setcounter{tocdepth}{2}
\makeatletter
\renewcommand*\l@author[2]{}
\renewcommand*\l@title[2]{}
\makeatletter



  \author{K. Prasanna Kumar\inst{1} \and Amey Karkare\inst{2}
    \and   Amitabha Sanyal\inst{1}}
  \institute{IIT Bombay, Mumbai 400076, India\\
    \email{$\{$prasanna,as$\}$@cse.iitb.ac.in}, \and 
             IIT Kanpur, Kanpur 208016, India\\
    \email{karkare@cse.iitk.ac.in}}
\maketitle

\begin{abstract}
\input{sections/abstract}
\end{abstract}

%------------------------------------------------------------%


%% \begin{figure}
%% \tableofcontents       %%%%%%% BEWARE: find the \setcounter{page}{2}
%%                        %%%%%%% and comment it out when deleting this TOC.
%% \vspace{5cm}

%% \section*{Page Budget}
%% CC'2014 and ESOP'2014 have a limit of 20 pages.
%% A draft page budget is:
%% \begin{itemize}
%% \item 1. abstract/introduction (3 pages)
%% {\color{red}Currently 2.5 pages.}
%% \item 2. core language syntax and semantics (2 pages).
%% {\color{red}Currently 2 pages.}
%% \item 3. liveness analysis and correctness (3 pages)
%% {\color{red}Currently 3.8 pages.}
%% \item 4. practical liveness computation (6 pages)
%% {\color{red}Currently 6.2 pages.}
%% \\ I think this is where should do all 3 of: the context-insensitive analysis
%% (one which has a summary demand for each function), then the
%% solving like differential equations, then using Mohri-Nederhof to
%% get a NFA for each (call/cons) program point.
%% \item 5. experimental framework and results (4 pages)
%% \item 6. (optional) monotonicity of GC (0.5 page)---our technique can never
%% cause more collections.
%% \item 7. conclusions/acknowledgements/bibliography (1.5 page)
%% \end{itemize}
%% \end{figure}

\input{sections/intro}
\input{sections/syntax-and-semantics}
\input{sections/liveness}

%\input{sections/restOfOldPaper}
\bibliography{fun_hra}{}
\bibliographystyle{splncs}

\end{document}
>>>>>>> 4bb03a5c3d7b9f8e48b056d77b2ef7801e7effa3
>>>>>>> 56ee31a761282a98c71537e433148fc7a9d2dce0

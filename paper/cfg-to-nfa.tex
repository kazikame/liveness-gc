We circumvent the problem of undecidability by over approximating the
CFG by non-deterministic finite state automata (NFA) using
%% The NFAs  are then simplified using the
%%$\hookrightarrow$ rules.   Finally the  simplified NFAs
%%are converted to DFAs.
%%
%% We use  the algorithm by 
Mohri  and Nederhof~\cite{mohri00regular} method.
%to approximate a CFG by a {\em strongly regular\/} grammar.  
For example, the grammar fragment for %the non-terminal
$\var{\Df{\length}{1}}$ after the Mohri-Nederhof transformation is:
 \begin{eqnarray*}
   \var{\Df{\length}{1}} &\rightarrow& \clazy\var{\Df{\length}{1'}} \mid
   \acdr\var{\Df{\length}{1}}
   \mid \clazy\var{\Df{\length}{1}}\\
   \var{\Df{\length}{1'}} &\rightarrow& \clazy\var{\Df{\length}{1'}}
   \mid \epsilon
 \end{eqnarray*}

The strongly regular grammar is converted  into a set of NFAs, one for
each $\var{\Lanv{x}{}}$.  The  $\hookrightarrow$ simplification is now
done on the NFAs by  repeatedly introducing $\epsilon$ edges to bypass
pairs  of consecutive  edges  labeled \bcar\acar\  or \bcdr\acdr\  and
constructing  the $\epsilon$-closure  till a  fixed point  is reached,
after which  the edges labeled  \bcar \  and \bcdr\ are  deleted.  
\cmt{ %% REMOVED FOR BLIND REVIEW
  The details of the  algorithm, its correctness and  termination proofs are
given  in~\cite{karkare07liveness,asati14lgc}. }
The
resulting  automaton   has  edges  labeled  with   \acar,  \acdr\  and
\clazy\ only.  In this  automaton, for every  edge labeled  \clazy, we
check if the source node of the edge has a path to a final 
state.  If it does, we mark  the source node as final. Finally, we
remove all the edges labeled \clazy\  and convert the automaton into a
deterministic    automaton.    These steps   effectively   implement    the
$\hookrightarrow$   simplification  rules   for   \bcar,  \bcdr,   and
\clazy\ to  obtain forward access paths.  While checking for  liveness during
garbage  collection, a  forward access path  is valid  only if  it can
reach a  final state.  Figure~\ref{fig:example-automata}(a)  shows the
NFA that is obtained from  the grammar for \var{\Df{\length}{1}}, and   the
final  DFA  is  shown in  Figure~\ref{fig:example-automata}(b).   This
expectedly  says that for a  demand  $\sigma_{\length}$,  the
liveness of  the argument of \length\  is $\acdr^{*}$  (the spine  of the  list is
traversed).  Similarly, Figure~\ref{fig:example-automata}(c) shows the
NFA     for     \var{\Lanv{\pa}{}}.      The     DFA in
Figure~\ref{fig:example-automata}(d)  does  not   accept  any  forward
paths, reflecting  the  lazy  nature  of  our  language.   Since
\length\ does not  evaluate the elements of  the argument list,
the  closure for  \pa\ is  never evaluated  and is  reclaimed whenever
liveness-based GC triggers beyond $\pi_9$.

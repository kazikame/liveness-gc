We circumvent the problem of undecidability by over approximating the
CFG by non-deterministic finite state automata (NFA) using
%% The NFAs  are then simplified using the
%%$\hookrightarrow$ rules.   Finally the  simplified NFAs
%%are converted to DFAs.
%%
%% We use  the algorithm by 
Mohri  and Nederhof~\cite{mohri00regular} method. This method transforms 
a given CFG into a strongly regular grammar. A strongly regular grammar 
is a grammar in which mutually recursive rules are all either right-linear
or left-linear grammars. 

In our example, the rule  $\var{\Df{\length}{1}}$ has two context free
productions,           $\acdr\var{\Df{\length}{1}}\clazy$          and
$\clazy\var{\Df{\length}{1}}{\clazy}$.   We  add another  non-terminal
$\var{\Df{\length}{1'}}$ to the grammar and we split each context free
production at the point where it refers to $\var{\Df{\length}{1}}$ and
the  remaining  symbols are  then  added  as  productions of  the  new
variable   $\var{\Df{\length}{1'}}$.   For   the  regular   production
$\clazy$,  we  add $\var{\Df{\length}{1'}}$  at  the  end and  add  an
$\epsilon$ transition to $\var{\Df{\length}{1'}}$.
%to approximate a CFG by a {\em strongly regular\/} grammar.  
The resulting grammar fragment for %the non-terminal
$\var{\Df{\length}{1}}$ after the Mohri-Nederhof transformation is:
 \begin{eqnarray*}
   \var{\Df{\length}{1}} &\rightarrow& \clazy\var{\Df{\length}{1'}} \mid
   \acdr\var{\Df{\length}{1}}
   \mid \clazy\var{\Df{\length}{1}}\\
   \var{\Df{\length}{1'}} &\rightarrow& \clazy\var{\Df{\length}{1'}}
   \mid \epsilon
 \end{eqnarray*}

The strongly regular grammar is converted  into a set of NFAs, one for
each $\var{\Lanv{x}{}}$.  The  $\hookrightarrow$ simplification is now
done on the NFAs by  repeatedly introducing $\epsilon$ edges to bypass
pairs  of consecutive  edges  labeled \bcar\acar\  or \bcdr\acdr\  and
constructing  the $\epsilon$-closure  till a  fixed point  is reached,
after which  the edges labeled  \bcar \  and \bcdr\ are  deleted.  
 \begin{wrapfigure}{r}{0.25\textwidth}
%\begin{figure}[t!]
\scalebox{0.5}{
  \begin{tabular}{cc}
\psset{unit=1mm,nodesep=0mm,labelsep=0.5mm}
\begin{pspicture}(0,-3)(50,12)
  \putnode{t0}{origin}{5}{0}{\var{\Df{\length}{1}}}
  \putnode{t1}{t0}{15}{0}{\pscirclebox{\mbox{\ \ \ \ }}} \hspace{5mm}
  \putnode{t2}{t1}{15}{0}{\pscirclebox[doubleline=true]{\mbox{\ \ \ \ }}}
  \psset{arrows=->}
  \ncline{t0}{t1}
  \ncline{t1}{t2}
  \putnode{l0}{t1}{7}{2}{\clazy}
  \nccurve[angleA=45, angleB=135, ncurv=4, nodesep=-1]{t1}{t1}
  \putnode{l1}{t1}{0}{8}{\acdr, \clazy}
  \nccurve[angleA=45, angleB=135, ncurv=3, nodesep=-1]{t2}{t2}
  \putnode{l2}{t2}{0}{8}{\clazy}
\end{pspicture}
&
\psset{unit=1mm,nodesep=0mm,labelsep=0.5mm}
\begin{pspicture}(0,-3)(30,12)
  \putnode{t0}{origin}{5}{0}{\var{\Df{\length}{1}}}
  \putnode{t1}{t0}{15}{0}{\pscirclebox[doubleline=true]{\mbox{\ \ \ \ }}}
  \psset{arrows=->}
  \ncline{t0}{t1}
  \nccurve[angleA=45, angleB=135, ncurv=3, nodesep=-1]{t1}{t1}
  \putnode{l1}{t1}{0}{8}{\acdr}
\end{pspicture}
\\
(a) & (b) \\
\psset{unit=1mm,nodesep=0mm,labelsep=0.5mm}
\begin{pspicture}(0,-5)(50,8) %\psframe(0,-5)(40,8)
  \putnode{t0}{origin}{5}{0}{\var{\Lanv{\pa}{}}}
  \putnode{t1}{t0}{9}{0}{\pscirclebox{\mbox{\ \ \ \ }}} \hspace{5mm}
  \putnode{t2}{t1}{12}{0}{\pscirclebox{\mbox{\ \ \ \ }}}
%  \putnode{t3}{t2}{12}{0}{\pscirclebox[doubleline=true]{\mbox{\ \ \ \ }}}
  \psset{arrows=->}
  \ncline{t0}{t1}
  \ncline{t1}{t2}
  \putnode{l0}{t1}{5}{2}{\clazy}
%  \ncline{t2}{t3}
%  \nccurve[angleA=55, angleB=125, ncurv=3, nodesep=-.8]{t3}{t3}
%  \putnode{l2}{tD1}{0}{10}{\acdr}
 \putnode{tD1}{t2}{12}{0}{\pscirclebox{\mbox{\ \ \ \ }}} \hspace{5mm}
  \putnode{tD2}{tD1}{12}{0}{\pscirclebox[doubleline=true]{\mbox{\ \ \ \ }}}
  \psset{arrows=->}
  \ncline{t2}{tD1}
  \putnode{l1}{t2}{5}{2}{\bcar}
  \ncline{tD1}{tD2}
  \putnode{lD0}{tD1}{5}{2}{\clazy}
  \nccurve[angleA=45, angleB=135, ncurv=4, nodesep=-1]{tD1}{tD1}
  \putnode{lD1}{tD1}{0}{8}{\acdr, \clazy}
  \nccurve[angleA=45, angleB=135, ncurv=3, nodesep=-1]{tD2}{tD2}
  \putnode{lD2}{tD2}{0}{8}{\clazy}
\end{pspicture}
&
\psset{unit=1mm,nodesep=0mm,labelsep=0.5mm}
\begin{pspicture}(0,-5)(20,8) %\psframe(0,-5)(40,8)
  \putnode{t0}{origin}{5}{0}{\var{\Lanv{\pa}{}}}
  \putnode{t1}{t0}{9}{0}{\pscirclebox{\mbox{\ \ \ \ }}} \hspace{5mm}
  \psset{arrows=->}
  \ncline{t0}{t1}
\end{pspicture}
\\ 
(c) & (d)  \end{tabular}}
\caption{(a) The  grammar rules for \var{\Df{\length}{1}}
  converted into an automaton, and (b) its DFA. The same for \var{\Lanv{\pa}{}}
  are in (c) and (d).}\label{fig:example-automata}
\vspace*{-2mm}
\figrule
%\end{figure}
\end{wrapfigure}
\cmt{ %% REMOVED FOR BLIND REVIEW
  The details of the  algorithm, its correctness and  termination proofs are
given  in~\cite{karkare07liveness,asati14lgc}. }
The
resulting  automaton   has  edges  labeled  with   \acar,  \acdr\  and
\clazy\ only.  In this  automaton, for every  edge labeled  \clazy, we
check if the source node of the edge has a path to a final 
state.  If it does, we mark  the source node as final. Finally, we
remove all the edges labeled \clazy\  and convert the automaton into a
deterministic    automaton.    These steps   effectively   implement    the
$\hookrightarrow$   simplification  rules   for   \bcar,  \bcdr,   and
\clazy\ to  obtain forward access paths.  While checking for  liveness during
garbage  collection, a  forward access path  is valid  only if  it can
reach a  final state. 
Figure~\ref{fig:example-automata}(a)  shows the
NFA that is obtained from  the grammar for \var{\Df{\length}{1}}, and   the
final  DFA  is  shown in  Figure~\ref{fig:example-automata}(b).   This
expectedly  says that for a  demand  $\sigma_{\length}$,  the
liveness of  the argument of \length\  is $\acdr^{*}$  (the spine  of the  list is
traversed).
Similarly, Figure~\ref{fig:example-automata}(c) shows the
NFA     for     \var{\Lanv{\pa}{}}.      The     DFA in
Figure~\ref{fig:example-automata}(d)  does  not   accept  any  forward
paths, reflecting  the  lazy  nature  of  our  language.   Since
\length\ does not  evaluate the elements of  the argument list,
the  closure for  \pa\ is  never evaluated  and is  reclaimed whenever
liveness-based GC triggers beyond $\pi_9$.

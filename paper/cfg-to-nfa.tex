We circumvent the problem of  undecidability by over approximating the
CFG by non-deterministic finite state automata (NFA) using
%% The NFAs  are then simplified using the
%%$\hookrightarrow$ rules.   Finally the  simplified NFAs
%%are converted to DFAs.
%%
%% We use  the algorithm by 
Mohri   and   Nederhof~\cite{mohri00regular}   method.   This   method
transforms a  given CFG  into a strongly  regular grammar. 

In our example, the rule  $\var{\Df{\length}{1}}$ has two context free
productions,           $\acdr\var{\Df{\length}{1}}\clazy$          and
$\clazy\var{\Df{\length}{1}}{\clazy}$.  We transform this grammar into
a strongly regular grammar in two steps,

\begin{enumerate}
\item
Add a  new non-terminal  $\var{\Df{\length}{1'}}$ to the  grammar with
the rule $\var{\Df{\length}{1'}} \rightarrow \epsilon$.
\item
Consider each production of $\var{\Df{\length}{1}}$,
\begin{enumerate}
\item
 replace     $\var{\Df{\length}{1}}     \rightarrow     \clazy$,     by
 $\var{\Df{\length}{1}} \rightarrow \clazy\var{\Df{\length}{1'}}$
\item
 replace
 $\var{\Df{\length}{1}} \rightarrow \clazy\var{\Df{\length}{1}}\clazy$,
 by  $\var{\Df{\length}{1}}  \rightarrow  \clazy\var{\Df{\length}{1}}$
 and $\var{\Df{\length}{1'}} \rightarrow \clazy\var{\Df{\length}{1'}}$
\item
 replace
 $\var{\Df{\length}{1}} \rightarrow \acdr\var{\Df{\length}{1}}\clazy$,
 by $\var{\Df{\length}{1}} \rightarrow \acdr\var{\Df{\length}{1}}$ and
 $\var{\Df{\length}{1'}} \rightarrow \clazy\var{\Df{\length}{1'}}$
\end{enumerate}
\end{enumerate}


The    resulting    grammar    fragment    for    %the    non-terminal
$\var{\Df{\length}{1}}$   after   the  Mohri-Nederhof   transformation
is:               \begin{eqnarray*}              \var{\Df{\length}{1}}
&\rightarrow& \clazy\var{\Df{\length}{1'}} \mid \acdr\var{\Df{\length}{1}} \mid \clazy\var{\Df{\length}{1}}\\ \var{\Df{\length}{1'}}
&\rightarrow& \clazy\var{\Df{\length}{1'}} \mid \epsilon \end{eqnarray*}
Notice that the language generated  by the strongly regular grammar is
a superset of the original CFG.


The strongly regular grammar is converted  into a set of NFAs, one for
each $\var{\Lanv{x}{}}$.  The  $\hookrightarrow$ simplification is now
done on the NFAs by  repeatedly introducing $\epsilon$ edges to bypass
pairs  of consecutive  edges  labeled \bcar\acar\  or \bcdr\acdr\  and
constructing  the $\epsilon$-closure  till a  fixed point  is reached,
after which  the edges labeled  \bcar \  and \bcdr\ are  deleted.  The
details of the  algorithm, its correctness and  termination proofs are
given in~\cite{karkare07liveness,asati14lgc}.

The resulting automaton has edges labeled with \acar, \acdr\ and
\clazy\ only.  In this  automaton, for every  edge labeled  \clazy, we
check if the source node of the edge  has a path to a final state.  If
it does, we mark the source node  as final. Finally, we remove all the
edges labeled \clazy\  and convert the automaton  into a deterministic
automaton.   These steps  effectively implement  the $\hookrightarrow$
simplification rules for \bcar, \bcdr, and
\clazy\ to  obtain forward access paths.  While checking for  liveness during
garbage collection,  a forward  access path  is valid  only if  it can
reach a final state.


\begin{wrapfigure}{r}{0.25\textwidth}
\scalebox{0.5}{
          \begin{tabular}{cc}
          \psset{unit=1mm,nodesep=0mm,labelsep=0.5mm}
          \begin{pspicture}(0,-3)(50,12)
            \putnode{t0}{origin}{5}{0}{\var{\Df{\length}{1}}} \putnode{t1}{t0}{15}{0}{\pscirclebox{\mbox{\ \ \ \
  }}} \hspace{5mm} \putnode{t2}{t1}{15}{0}{\pscirclebox[doubleline=true]{\mbox{\ \ \ \
  }}} \psset{arrows=->} \ncline{t0}{t1} \ncline{t1}{t2} \putnode{l0}{t1}{7}{2}{\clazy} \nccurve[angleA=45,
  angleB=135,                                                 ncurv=4,
  nodesep=-1]{t1}{t1} \putnode{l1}{t1}{0}{8}{\acdr, \clazy} \nccurve[angleA=45,
  angleB=135,                                                 ncurv=3,
  nodesep=-1]{t2}{t2} \putnode{l2}{t2}{0}{8}{\clazy}
\end{pspicture}
&
\psset{unit=1mm,nodesep=0mm,labelsep=0.5mm}
\begin{pspicture}(0,-3)(30,12)
  \putnode{t0}{origin}{5}{0}{\var{\Df{\length}{1}}} \putnode{t1}{t0}{15}{0}{\pscirclebox[doubleline=true]{\mbox{\ \ \ \
  }}}     \psset{arrows=->}    \ncline{t0}{t1}     \nccurve[angleA=45,
  angleB=135,                                                 ncurv=3,
  nodesep=-1]{t1}{t1} \putnode{l1}{t1}{0}{8}{\acdr}
\end{pspicture}
\\
(a) & (b)
 \end{tabular}}
\caption{(a) The  grammar rules for \var{\Df{\length}{1}}
  converted      into      an      automaton     and      (b)      its
  DFA.}\label{fig:example-automata}
\figrule
\vspace*{-5mm}
\end{wrapfigure}

Figure~\ref{fig:example-automata}(a)  shows the  NFA that  is obtained
from the grammar for \var{\Df{\length}{1}}, and the final DFA is shown
in  Figure~\ref{fig:example-automata}(b).  This  expectedly says  that
for  a  demand  $\sigma_{\length}$,   the  liveness  of  the  argument
of \length\ is $\acdr^{*}$ (the spine of the list is traversed).

\input{main-pgm1}
For the main  program~\ref{fig:main-pgm1}, the automaton corresponding
to  the  variable   \var{\Lanv{\pa}{}}  and  its  DFA   are  shown  in
Figure~\ref{fig:main1}.  The DFA in Figure~\ref{fig:main1}(b) does not
accept any forward paths, reflecting  the lazy nature of our language.
Since
\length\ does not  evaluate the elements of  the argument list,
the  closure for  \pa\ is  never evaluated  and is  reclaimed whenever
liveness-based GC triggers beyond $\pi_9$.


\begin{wrapfigure}{r}{.25\textwidth}
\scalebox{0.5}{
\begin{tabular}{c}
\psset{unit=1mm,nodesep=0mm,labelsep=0.5mm}
\begin{pspicture}(0,-5)(50,8) %\psframe(0,-5)(40,8)
  \putnode{t0}{origin}{5}{0}{\var{\Lanv{\pa}{}}} \putnode{t1}{t0}{9}{0}{\pscirclebox{\mbox{\ \ \ \
  }}} \hspace{5mm} \putnode{t2}{t1}{12}{0}{\pscirclebox{\mbox{\  \ \ \
  }}}
  \psset{arrows=->} \ncline{t0}{t1} \ncline{t1}{t2} \putnode{l0}{t1}{5}{2}{\clazy}
  \putnode{tD1}{t2}{12}{0}{\pscirclebox[doubleline=true]{\mbox{\       \       \       \
  }}} 
  \psset{arrows=->} \ncline{t2}{tD1} \putnode{l1}{t2}{5}{2}{\bcar}
  \nccurve[angleA=45,
  angleB=135,                                                 ncurv=4,
  nodesep=-1]{tD1}{tD1} \putnode{lD1}{tD1}{0}{10}{\acdr}
\end{pspicture} 
\\
(a)
\\
\psset{unit=1mm,nodesep=0mm,labelsep=0.5mm}
\begin{pspicture}(0,-5)(50,8) %\psframe(0,-5)(40,8)
  \putnode{t0}{origin}{5}{0}{\var{\Lanv{\pa}{}}} \putnode{t1}{t0}{9}{0}{\pscirclebox{\mbox{\ \ \ \
  }}} 
  \hspace{5mm} 
  \putnode{t2}{t1}{12}{0}{\pscirclebox{\mbox{\  \ \ \  }}}
  \psset{arrows=->} \ncline{t0}{t1} \ncline{t1}{t2} 
\end{pspicture}
\\
(b)
\\
\psset{unit=1mm,nodesep=0mm,labelsep=0.5mm}
\begin{pspicture}(0,-5)(50,8) %\psframe(0,-5)(40,8)
  \putnode{t0}{origin}{5}{0}{\var{\Lanv{\pa}{}}} \putnode{t1}{t0}{9}{0}{\pscirclebox{\mbox{\ \ \ \
  }}} \hspace{5mm} \psset{arrows=->} \ncline{t0}{t1}
\end{pspicture}
\\ 
(c)
\end{tabular}}
 \caption{(a) grammar  rules for \var{\Lanv{\pa}{}} converted  into an
  automaton and  its DFAs after simplification.}\label{fig:main1}
\end{wrapfigure}

If the expression at $\pi_{12}$ in the main program in Figure~\ref{fig:main-pgm1} was 
$\CAR~\pc$, then the liveness of $\pc$ would be $(\clazy\sigma_{all}, \acar\sigma_{all})$.





 



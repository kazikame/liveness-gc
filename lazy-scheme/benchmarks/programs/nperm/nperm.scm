
(define (and anx any) (if (eq? anx #t) any #f))

(define (or orx ory) (if (eq? orx #t) orx ory))

(define (append res1 res2)
  (if (null? res1)
      res2
      (cons (car res1) (append (cdr res1) res2))
      )
  )
(define (getVal list i)
  (if (eq? 0 i)
      (car list)
      (getVal (cdr list) (- i 1))
      )
  )

(define (swapij list i j ival jval)
  (if (and (< i 0) (< j 0))
      list
      (if (eq? 0 i)
          (cons jval (swapij (cdr list) (- i 1) (- j 1) ival jval))
          (if (eq? 0 j)
              (cons ival (swapij (cdr list) (- i 1) (- j 1) ival jval))
              (cons (car list) (swapij (cdr list) (- i 1) (- j 1) ival jval))
              )
          )
      )
  )

(define (swap list i j)
  (let ((ival (getVal list i) ))
    (let ((jval (getVal list j) ))
      (swapij list i j ival jval)
      )
    )
  )
              
(define (loop list i k n result)
  (if (eq? i n)
      result
      (let ((newlist (swap list i (- n 1)) ))
        (let (( cresult (permute newlist k (- n 1)) ))
          (loop list (+ i 1) k n (append result cresult))
          )
        )
      )
  )

(define (permute list k n)
  (if(eq? k n)
     (cons list '())
     (loop list k k n '())
     )
  )
  

(define (makeList n list)
  (if (eq? 0 n)
      list
      (makeList (- n 1) (cons n list))
      )
  )

(define (permutation n)
  (permute (makeList n '()) 0 n)
  )

(define (make-queue size)
  (if (eq? size 0)
      '()
      (cons '() (make-queue (- size 1)))
      )
  )

(define (fill i n queue)
  (if (eq? 0 i)
      (cons (permutation n) (cdr queue))
      (cons (car queue) (fill (- i 1) n (cdr queue)))
      )
  )

(define (fill-queue i j n queue)
  (if (< i j)
      (let ((newq (fill i n queue) ))
        (fill-queue (+ i 1) j n newq)
        )
      queue
      )
  )

(define (get-ref  j queue)
  (if (eq? 0 j)
      (car queue)
      (get-ref (- j 1) (cdr queue))
      )
  )

(define (set-ref i ref queue)
  (if (eq? 0 i)
      (cons ref (cdr queue))
      (cons (car queue) (set-ref (- i 1) ref (cdr queue)))
      )
  )
(define (loop-flush i k l queue)
  (if (< i k)
      (let ((j (+ i l) ))
        (if (< j k)
            (let ((ref (get-ref j queue) ))
              (let ((newq (set-ref i ref queue) ))
                (loop-flush (+ 1 i) k l newq)
                )
              )
            (let ((newq (set-ref i '() queue) ))
              (loop-flush (+ 1 i) k l newq)
              )
            )
        )
      queue
      )
  )
  
(define (flush-queue k l queue)
  (loop-flush 0 k l queue)
  )

(define (run-operations m n k l queue)
  (if (eq? 0 m)
       queue
      (let ((queuefill (fill-queue (- k l) k n queue) ))
        (let ((queueflush (flush-queue k l queuefill) ))
          (run-operations (- m 1) n k l queueflush)
          )
        )
      )
  )
        
          
(define (MpermNKL-benchmark m n k l)
  (let ((queue (make-queue k) ))
    (run-operations m n k l queue)
    )
  )
(define (tenperm-benchmark m n k l)
  (MpermNKL-benchmark m n k l)
  )
(tenperm-benchmark 10 7 2 1)

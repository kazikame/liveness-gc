%% For Slides
\documentclass[xcolor=x11names,compress,mathserif]{beamer}
%% For handouts
%\documentclass[xcolor=x11names,compress,mathserif,12pt,handout]{beamer}
%% To put multiple pages (say 2x3) per page in pdf,  use command 
%% pdfnup --a4paper --keepinfo --nup 2x3 --frame true \
%%      --scale 0.95 --no-landscape --outfile handout.pdf <input>.pdf
%% End of For Handout

\usepackage{etex}
%% Beamer Layout %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\useoutertheme[subsection=false,shadow]{miniframes}
\useinnertheme{default}
\usefonttheme{structureitalicserif}
\usepackage{palatino}
%% packages from the paper
\usepackage{schemepgm}
\usepackage{graphicx}
\usepackage{mathrsfs}
\usepackage{graphpap}
\usepackage{tabularx}
\usepackage{epsfig}
\usepackage{pstricks}
\usepackage{pst-text}
\usepackage{pst-node}
\usepackage{pst-tree}
\usepackage{pst-rel-points}
\usepackage{boxedminipage}
\usepackage{algorithmic}
\usepackage{amssymb}
\usepackage{amsmath}
\input{fh_defs}
%% packages from the paper
\setbeamerfont{title like}{shape=\scshape}
\setbeamerfont{frametitle}{shape=\scshape}

\setbeamercolor*{lower separation line head}{bg=DeepSkyBlue4} 
\setbeamercolor*{normal text}{fg=black,bg=white} 
\setbeamercolor*{alerted text}{fg=red} 
\setbeamercolor*{example text}{fg=black} 
\setbeamercolor*{structure}{fg=black} 
 
\setbeamercolor*{palette tertiary}{fg=black,bg=black!10} 
\setbeamercolor*{palette quaternary}{fg=black,bg=black!10} 

\renewcommand{\(}{\begin{columns}}
\renewcommand{\)}{\end{columns}}
\newcommand{\<}[1]{\begin{column}{#1}}
\renewcommand{\>}{\end{column}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\scshape Motivation}
\begin{frame}
\title{Liveness-Based Garbage Collection for Lazy Languages}
\author{
        {\bf Prasanna Kumar, Amitabha Sanyal}\\{\it Indian Institute of
          Technology, Bombay}\\ \and
       {\bf Amey Karkare}\\{\it Indian Institute of Technology, Kanpur}
}

%% \date{
%% 	%% \begin{tikzpicture}[decoration=Koch curve type 2] 
%% 	%% 	\draw[DeepSkyBlue4] decorate{ decorate{ decorate{ (0,0) -- (3,0)}}}; 
%% 	%% \end{tikzpicture}  
%% 	%% \\
%% 	June 14th, 2016
%% }
\date{\today}
\titlepage
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \begin{frame}{Outline of Talk}
%% \tableofcontents
%% \end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Liveness based GC}
    \begin{itemize}\itemsep0.75em
    \item During execution, there are significant amounts of heap allocated data
      that  are {\em  reachable but not live}.
      \begin{itemize}
      \item Current GCs will retain such data.
      \end{itemize}
    \item Our idea: 
      \begin{itemize}
      \item We do  a liveness analysis of {\em heap  data} and provide
        GC with its result.
      \item Modify GC to mark data for retention {\em only if it is live}.
      \end{itemize}
    \item Consequences:
      \begin{itemize}
      \item  Fewer cells  marked.  \pause More  garbage collected  per
        collection. \pause Fewer garbage collections. \pause
      \item Programs expected to run faster and with smaller heap.
      \end{itemize}
    \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{An Example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% MOTIVATING EXAMPLE
\input{motivating-example}

\bigskip
\begin{itemize}
\item<1->{\em  Expression $(+\ 5\ 2)$ never gets evaluated and $(+\ 4\ 5)$ gets evaluated only if $*$ is false.}  
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\scshape Our method}

%% \begin{frame}{Liveness Information}
%%   \begin{itemize}
%%   \item Our analysis captures liveness as automata.
%%   \end{itemize}
%% \begin{columns}
%%   \begin{column}[T]{0.5\textwidth}
%% \input{example-automata}
%%   \end{column}
%%   \begin{column}[T]{0.5\textwidth}
%%     \input{example-heap-snap-shot}
%%   \end{column}
%% \end{columns}
%% \end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{The language analyzed}
\begin{columns}
  \begin{column}[T]{0.45\textwidth}
\small
    \begin{itemize} \itemsep0.75em
    \item First order Scheme-like lazy functional language.
    \item In Administrative Normal Form (ANF).
%    \item The order  of
%      evaluation of function arguments is made explicit.
    \end{itemize}
\normalsize
  \end{column}
  \begin{column}[T]{0.55\textwidth}
    \input{language-being-analysed}
  \end{column}
\end{columns}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\scshape LGC for lazy languages}
\begin{frame} {Lazy evaluation}
\begin{itemize}
\item An evaluation  strategy in which evaluation of  an expression is
  postponed until its value is needed
  \begin{itemize}
  \item Binding  of a  variable to  an expression  {\bf does  not force
    evaluation} of the expression
  \end{itemize}
\item Every expression is evaluated at most once
\end{itemize}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\scshape Liveness}
\begin{frame}{Liveness -- Basic Concepts and Notations}
\small
\begin{columns}
  \begin{column}[T]{0.75\textwidth}
    \begin{itemize}\itemsep0.75em
    \item {\em Access paths:} Strings over \{\acar, \acdr\}.
      
      \hspace*{.25cm}   \acar\  -- access \CAR\ field \\
      \hspace*{.25cm}   \acdr\  -- access \CDR\ field 
    \item Denote traversals over the heap graph
    \item {\em Liveness environment:} 
      \only<1>
          {Maps root variables    to set of access paths.
            \begin{eqnarray*}
              \Lanv{i}{}&:&
              \left\{\begin{array}{l}
              y \mapsto \emptyset\\
              z \mapsto \{\epsilon\}\\
              w \mapsto \{\epsilon, 1, 10, 100\}
              \end{array}\right.
            \end{eqnarray*}
          }
          \only<2>
              {Alternate representation.
                \begin{eqnarray*}
                  \Lanv{i}{}&:&
                  \left\{\begin{array}{l}
                  \emptyset \;\; \cup  \\
                  \{z.\epsilon\} \;\; \cup\\
                  \{w.\epsilon, w.1, w.10, w.100\}
                  \end{array}\right.
                \end{eqnarray*} 
              }
    \end{itemize}
  \end{column}
  \begin{column}[T]{0.25\textwidth}
    \fbox{\centerline{\epsfig{file=example-liveness-environment.eps, height=5cm}}}
  \end{column}
\end{columns}

\bigskip
\bigskip

\onslide<1>{Notation: We write \Lanv{i}{}(\px) as  \normalsize\Lanv{i}{\px}}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Demand}
  \begin{center}
     (\CAR\ (\CDR\ \pw)) \\
  \end{center}
  \pause
\centerline{\input{example-heap-snap-shot}}
  \begin{itemize}
  \item Demand  (notation: $\sigma$) is a description  of intended use
    of the result of an expression.
   \pause
\item We assume the demand on the main expression to be $(0+1)^*$,
  which we call $\sigma_{all}$.
\item The demands on each function body, $\sigma_f$, have to be computed.
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Liveness analysis}
  \begin{itemize}
  \item {\bf  GOAL:} Compute  Liveness Environment at  various program
    points, statically.
  \end{itemize}
  \bigskip\pause
  \Lapp{a}{\sigma}  --  Liveness  environment  generated  by  an  {\em
    application} $a$, given a demand $\sigma$.\\
  \bigskip
  \Lexp{e}{\sigma} -- Liveness environment  before an {\em expression}
  $e$, given a demand $\sigma$.

\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame} {Handling possible non-evaluation}
  \begin{itemize}
  \item Liveness no longer remains independent of demand $\sigma$ \\
    \begin{itemize}
    \item If (\CAR~\px) is not evaluated at all, it should not generate any liveness for \px
    \end{itemize}
  \item Require a new terminal \clazy\ with following semantics
    \begin{align*}
      \clazy\sigma \hookrightarrow & \left\{ 
      \begin{array}{ll}
        \emptyset&\mbox{if}~\sigma = \emptyset\\
        \{\epsilon\} & \mbox{otherwise}
      \end{array}\right.\\ & \\
      \Lapp{(\CAR \;\px)}{\sigma} &= \px.\{\clazy, \acar\}\sigma
    \end{align*}
  \end{itemize}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Handling lazy semantics: Closures}
\normalsize
  \begin{itemize}\itemsep2em
  \item Laziness complicates liveness analysis itself. 
    \begin{itemize}
    \item Data is made live by evaluation of closures
    \item In lazy languages, the place in the program
      where this evaluation takes place cannot be statically determined
    \end{itemize}
    \pause
  \item Liveness-based garbage collector significantly more complicated than that for an eager language.
    \begin{itemize}
    \item Need to track liveness of closures
    \item But a closure can escape the scope in which it was created
     \item Solution: carry the liveness information in the closure itself
     \item For precision: need to update the liveness information as execution progresses
    \end{itemize}
  \end{itemize}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Liveness analysis of Expressions}

\normalsize
$\Lexp{{\red{(return\; x)}}}{\sigma} = \{x.\sigma\}$


\bigskip
\medskip

  $\Lexp{{\red{(\SIF \; x\;\;  e_1\; \; e_2)}}}{\sigma} = \{x.\epsilon\} 
 \cup \Lexp{{\red{ e_1}}}{\sigma} \cup \Lexp{{\red{e_2}}}{\sigma}$



\bigskip
\medskip

$  \Lexp{{\red{(\LET \; x\; \leftarrow \; s \; \IN \; e)}}}{\sigma} = \Lv
           \setminus \{x.*\}
           \cup \mathit{\Lapp{s}{\Lv(x)}}$\\
\hspace*{4.5cm} $ \mbox{ where } \Lv = \mathcal{L}exp(e,\sigma)$

\bigskip

\pause
Notice the similarity with:
\bigskip

\centerline{$\mathit{live}_\mathit{in}(I)      =     \mathit{live}_\mathit{out}(I)
\setminus \mathit{def\/}(I) \cup \mathit{ref\/}(I)$}
\bigskip

in classical dataflow analysis for imperative languages.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Liveness analysis of Primitive Applications}
\small
\onslide<1-2>{
  \begin{columns}[c]
    \begin{column}{0.35\textwidth}
      \bigskip
      %\centerline{\epsfig{file=live-analysis1.eps, height=2cm}}
      \scalebox{.65}{
          \psset{unit=1mm}
          \psset{linewidth=.5mm}
          \begin{pspicture}(0,0)(90,0)
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            \putnode{x}{origin}{13}{-10}{\TwoCells{x0}{x1}}
            \putnode{startx}{x}{0}{-3}{}
            \putnode{after0}{x}{-5}{-30}{}
            \putnode{result}{origin}{32}{10}{\TwoCells{resultx}{resulty}}
            \putnode{labx}{x}{-7}{10}{\large $(\CAR\ x)$\;{\red $\sigma$} }
            \putnode{labr}{result}{-12}{12}{\large $x$}
            
            \onslide<1>{\nccurve[nodesepB=-.2,nodesepA=.5,angleA=295,angleB=135]{->}{labr}{result}}
            \onslide<2>{\nccurve[nodesepB=-.2,nodesepA=.5,angleA=295,angleB=135,linecolor=red]{->}{labr}{result}}
            \nccurve[nodesepB=-.2,angleA=295,angleB=135]{->}{labx}{x}
            \onslide<1>{\nccurve[nodesepB=-.2,angleA=270,angleB=75]{*->}{resultx}{x} \bput(.5){\large \acar}}
            \onslide<2>{\nccurve[nodesepB=-.2,angleA=270,angleB=75,linecolor=red]{*->}{resultx}{x} \bput(.5){\large \acar}}
            \onslide<2>{\nccurve[nodesepB=-.2,angleA=270,angleB=75,
                linestyle=dashed,linecolor=red]{*->}{startx}{after0}
              \bput(.5){\large $\alpha$}}
          \end{pspicture}
      }
    \end{column}
    \begin{column}{0.65\textwidth}
      $\Lapp{{\red{(\CAR \;x)}}}{\sigma} = \{x.\epsilon, \; x.\acar\sigma\}$
    \end{column}
  \end{columns}
  \pause
  \bigskip
  \bigskip
  \bigskip
}
\only<3->{ 
  \begin{columns}[c]
    \begin{column}[T]{0.35\textwidth}
      %\centerline{\epsfig{file=live-analysis2.eps, height=2.5cm}}
    \end{column}
    \begin{column}[T]{0.65\textwidth}
      \begin{minipage}{\textwidth}
        \begin{eqnarray*}
          \Lapp{{\red{(\CONS \;x \;y)}}}{\sigma} &=&  \{x.\alpha \mid \acar\alpha \in \sigma\} \; \cup\\
          & &  \{y.\beta \mid \acdr\beta \in \sigma\}
        \end{eqnarray*}
        
        \onslide<5->{
          \begin{itemize}
          \item 
            \bcar\ -- Removal of a leading \acar
            \\
            \bcdr\  -- Removal of a leading \acdr
            
          \end{itemize}
          \begin{eqnarray*}
            \Lapp{{\red{(\CONS \;x \;y)}}}{\sigma} &=&  x.\bcar\sigma \cup  y.\bcdr\sigma
        \end{eqnarray*}}
      \end{minipage}
    \end{column}
  \end{columns}

\raisebox{25mm}{\scalebox{.65}{
    \psset{unit=1mm}
    \psset{linewidth=.5mm}
    \begin{pspicture}(0,0)(90,0)
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      \putnode{x}{origin}{-3}{40}{\TwoCells{x0}{x1}}
      \putnode{y}{x}{51}{0}{\TwoCells{y0}{y1}}
      \putnode{startx}{x}{0}{-3}{}
      \putnode{starty}{y}{0}{-3}{}
      \putnode{after0}{x}{-5}{-30}{}
      \putnode{after1}{y}{5}{-30}{}
      \putnode{result}{origin}{22}{60}{\TwoCells{resultx}{resulty}}
      \putnode{labx}{x}{-7}{10}{\large $x$}
      \putnode{laby}{y}{7}{10}{\large $y$}
      \putnode{labr}{result}{-12}{12}{\large $(\CONS\ x\ y)$\; {\red $\sigma$} }

      \nccurve[nodesepB=-.2,angleA=295,angleB=135]{->}{labr}{result}
      \nccurve[nodesepB=-.2,angleA=295,angleB=135]{->}{labx}{x}
      \nccurve[nodesepB=-.2,angleA=270,angleB=45]{->}{laby}{y}
      \nccurve[nodesepB=-.2,angleA=270,angleB=75]{*->}{resultx}{x}
      \onslide<4->{        \bput(.5){\large \acar}}
      \nccurve[nodesepB=-.2,angleA=270,angleB=105]{*->}{resulty}{y}
      \onslide<4->{        \aput(.5){\large \acdr}}
      \onslide<4->{\nccurve[nodesepB=-.2,angleA=270,angleB=75,
          linestyle=dashed]{*->}{startx}{after0}
        \bput(.5){\large $\alpha$}
	\nccurve[nodesepB=-.2,angleA=270,angleB=105,
          linestyle=dashed]{*->}{starty}{after1}
        \aput(.5){\large ${\mathbf \beta}$}}
    \end{pspicture}
}}}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}{Liveness Analysis of User Defined Functions}
  \input{sample-liveness-program}
  \begin{itemize}
  \item Compute liveness of \pz\ at $\pi_{10}$.
  \item Get context independent summary of \plength\ ($\Lf{\plength}{1}{\sigma}$).
  \item Use demand on function application as the actual $\sigma$ to get liveness of \pz.
  \end{itemize}
\end{frame}

\begin{frame}{Liveness Analysis of Function Applications}
\onslide<1->{
  \begin{columns}[c]
    \begin{column}{0.4\textwidth}
      \onslide<1->{
        %\centerline{\epsfig{file=live-analysis4.eps, height=2.6cm}}
        \raisebox{-35mm}{\scalebox{.65}{
            \psset{unit=1mm}
            \psset{linewidth=.5mm}
            \begin{pspicture}(-10,0)(80,0)
              %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
              \putnode{x}{origin}{0}{30}{\TwoCells{x0}{x1}}
              \putnode{y}{x}{51}{0}{\TwoCells{y0}{y1}}
              \putnode{startx}{x}{0}{-3}{}
              \putnode{starty}{y}{0}{-3}{}
              \putnode{after0}{x}{-5}{-20}{}
              \putnode{after1}{y}{5}{-20}{}
              \putnode{result}{origin}{25}{50}{\OneCell{resultx}}
              \putnode{labx}{x}{-7}{10}{\large $x$}
              \putnode{laby}{y}{7}{10}{\large $y$}
              \putnode{labr}{result}{-12}{7}{\large $(f\ x\ y)$\; {\red $\sigma$} }
              
              \nccurve[nodesepB=-.2,angleA=295,angleB=135]{->}{labr}{result}
              \nccurve[nodesepB=-.2,nodesepA=.2,angleA=295,angleB=135]{->}{labx}{x}
              \nccurve[nodesepB=-.2,angleA=270,angleB=45]{->}{laby}{y}
              \onslide<2>{
                \nccurve[nodesepB=-.2,angleA=270,angleB=75,linestyle=dashed]{*->}{resultx}{x}
                \bput(.6){\large $\psi_x$}
                \nccurve[nodesepB=-.2,angleA=270,angleB=105,linestyle=dashed]{*->}{resultx}{y}
                \aput(.6){\large $\psi_y$}
              }
              \onslide<3->{
                \nccurve[nodesepB=-.2,angleA=270,angleB=75,linestyle=dashed]{*->}{resultx}{x}
                \bput(.6){\large \Lf{f}{1}{\alpha}}
                \nccurve[nodesepB=-.2,angleA=270,angleB=105,linestyle=dashed]{*->}{resultx}{y}
                \aput(.6){\large \Lf{f}{2}{\beta}}

              }
              \nccurve[nodesepB=-.2,angleA=270,angleB=105]{*->}{resulty}{y}
              \onslide<2->{\nccurve[nodesepB=-.2,angleA=270,angleB=75,
                  linestyle=dashed]{*->}{startx}{after0}
                \onslide<2>{\bput(.5){\large $\alpha$}}
	        \nccurve[nodesepB=-.2,angleA=270,angleB=105,
                  linestyle=dashed]{*->}{starty}{after1}
                \onslide<2>{\aput(.5){\large ${\mathbf \beta}$}}
              }
            \end{pspicture}
      }}}
    \end{column}
    \begin{column}{0.5\textwidth}
      \small
      \mbox{\onslide<1->{$\Lapp{{\red{(f \;x \;y)}}}{\sigma} =$}
        \onslide<2->{
          \alt<2>{$x.\overline{\psi_x}{\sigma} \cup  \;  y.\overline{\psi_y}{\sigma}$}{$x.\Lf{f}{1}{\sigma} \cup  \;  y.\Lf{f}{2}{\sigma}$}
        }}
    \end{column}
  \end{columns}
}
{
  \bigskip
  \begin{itemize}
    \onslide<3->{  \item We use \Lfonly$_{\mathit  f}$: context independent summary of  $f$.}
    \onslide<4-> {\item To find \Lf{\mathit  f}{i}{\ldots}: 
      \begin{itemize}
      \item Assume a symbolic demand $\sigma_{sym}$.
      \item Let $e_f$ be the body of $f$. 
      \item Set \Lf{\mathit f}{i}{\sigma_{sym}} to
        \Lexp{e_f}{\sigma_{sym}}($x_i$).  
        \onslide<5->{
        \item How to handle recursive calls?         
          \onslide<6->{
            {\red Use  \Lfonly$_{\mathit  f}$ with appropriate demand~!!}
        }}
    \end{itemize}}
  \end{itemize}
}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Liveness analysis -- Demand Summary}

\setbeamercovered{transparent}
\small
\begin{columns}[c]
 \begin{column}[T]{0.5\textwidth}
   \hspace*{-.3cm}\renewcommand{\arraystretch}{1}{
     \begin{uprogram}
       \UNL{1}\hspace*{-.4cm} $\pi_\mainpgm\!\!:\, $(\onslide<0>{\LET\  \px\  $\leftarrow$ ($\CONS$ ($+$ 5 2) \NIL)  \IN}
       \UNL{2}   \hspace*{-.3cm}   $\pi_9\!\!:\, $\onslide<0>{(\LET\ \pz\ $\leftarrow$ ($\CONS$ ($+$ 4 5 ) \px) \IN}
       \UNL{3}   \hspace*{-.3cm}   $\pi_{10}\!\!:\, $\onslide<0>{(\SIF\ $*$}
       \UNL{4}   \hspace*{-.35cm} $\pi_{11}\!\!:\, $\onslide<0>{(\LET\ \pw\  $\leftarrow$}  (\plength\ \pz) \onslide<0>{(\IN}
       \UNL{5}   \hspace*{-.38cm}  $\pi_{12}\!\!:\, $\onslide<0>{(\RETURN\ \pw)} 
       \UNL{4}   \hspace*{-.35cm}  $\pi_{13}\!\!:\, $\onslide<0>{(\LET\ \pb\  $\leftarrow$ (\pfun\  \pz) \IN}
       \UNL{5}   \hspace*{-.38cm} $\pi_{14}\!\!:\,$\onslide<0>{(\RETURN\ \pb))))))}
   \end{uprogram}}
 \end{column}
 \begin{column}[T]{0.5\textwidth}
\hspace*{.4cm}  \renewcommand{\arraystretch}{1}{
  \begin{uprogram}
     \UNL{1} (\DEFINE\ (\plength~\lista)

    \UNL{2}  $\pi_1\!\!:\, $\onslide<0>{(\LET\ \xtest\ $\leftarrow $\ (\NULLQ~\lista) \IN}


    \UNL{3}     $\pi_2\!\!:\, $\onslide<0>{(\SIF\ \xtest}

~$\pi_3\!\!:$\onslide<0>{(\RETURN\ $0$)} 
 
          \UNL{4} \hspace*{-.05cm}    
 $\pi_4\!\!:\, $\onslide<0>{(\LET\ \xtl\  $\leftarrow$\   (\CDR\ \lista) \IN}

	  \UNL{5}  \hspace*{-.05cm}
          $\pi_5\!\!:\,$\onslide<0>{(\LET\ \xrec\  $\leftarrow$} (\plength\ \ \xtl\ ) \onslide<0>{\IN}


          \UNL{6} \hspace*{-.05cm}   $\pi_6\!\!:\, $\onslide<0>{(\LET\ \xhd\  $\leftarrow$  $1$)  \IN}


          \UNL{7}  \hspace*{-.05cm}   $\pi_7\!\!:\,$\onslide<0>{(\LET\ \xans\  $\leftarrow$ ($+$\ \ \xhd\ \ \xrec)  \IN} 

          \UNL{8} \hspace*{-.05cm}
$\pi_8\!\!:\, $ \onslide<0>{(\RETURN\ \xans)))))))}
 
\end{uprogram}}
 \end{column}
\end{columns}
\setbeamercovered{invisible}
      \raisebox{-25mm}{\scalebox{.85}{
	%%%%%%%%%%%%%%%%%%%%%Uday's stuff%%%%%%%%%%%%%%%%%%%%%%%%%
      \psset{unit=1mm}
      \psset{linewidth=.3mm}
      \begin{pspicture}(0,0)(180,30)
%\psgrid[xunit=1cm,yunit=1cm,gridwidth=.2pt,subgridwidth=.1pt,subgriddiv=5,subgridcolor=gray,gridcolor=blue](0,0)(18,10)
	%\psframe(0,0)(73,60)
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\onslide<1-5>{\putnode{o}{origin}{26}{72}{\large\red $\sigma_{\xmain} =
          \sigma{_{all}}$}}
	\onslide<2-5>{\putnode{call1}{origin}{41}{58}{\large\red $\sigma_1$} 
	\nccurve[nodesepB=-.2,angleA=270,angleB=135,linecolor=red]{->}{o}{call1}}
	\onslide<3-5>{\putnode{appendentry}{origin}{85}{72}{\large\red
          $\sigma_{\plength} = \sigma_1 \cup \only<3-4>{\ldots} 
\only<5->{\sigma_2}$}
	\nccurve[nodesepB=-.2,angleA=45,angleB=165,linecolor=red]{->}{call1}{appendentry}}
	\onslide<4-5>{\putnode{call2}{origin}{125}{52}{\large\red $\sigma_2$} 
	\nccurve[nodesepB=-.2,angleA=270,angleB=135,linecolor=red]{->}{appendentry}{call2}}
	\onslide<5-5>{\nccurve[nodesepB=-.2,angleA=65,angleB=0,linecolor=red]{->}{call2}{appendentry}}

      \end{pspicture}}}

\vspace*{-2cm}
\footnotesize
\begin{columns}[c]
  \begin{column}[T]{0.40\textwidth}
    \scriptsize
    \centerline{\bf Liveness environments:}
    \bigskip
    $\Lanv{1}{\lista} = \{\epsilon\} \cup  \acar\bcar\sigma_\append\; \cup $\\
    $\;\;\;\;\;\;\;\;\;\;\;\acdr\Lf{\append}{1}{\bcdr\sigma_{\append}}$\\
    $\Lanv{1}{\listb} = \sigma \cup \Lf{\append}{2}{\bcdr\sigma_{\append}}$\\
    \ldots\\
    $\Lanv{9}{\py}  = $ \Lf{\append}{1}{\{\epsilon,
      \acdr\} \cup \acdr\acar\sigma_{\mathit{\!all}}} \\
  \end{column}
  \begin{column}[T]{0.30\textwidth}
    \scriptsize
    \centerline{\bf Demand summaries:}
    \onslide<6>{
      \begin{align*}
        &\sigma_{\xmain} = \sigma_{all}\\
        &\sigma_{\plength} = \sigma_{all} \cup \clazy\sigma_{\plength}
      \end{align*}
    }
  \end{column}
  \begin{column}[T]{0.38\textwidth}
    \scriptsize
    \centerline{\bf Function summaries:}
    \bigskip
    $\Lf{\plength}{1}{\sigma} = \{\clazy\sigma\} \cup \Lf{\plength}{1}{\acdr\sigma}$
  \end{column}
\end{columns}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[t]{Summary of Analysis Results}
  \scriptsize
  \begin{columns}[c]
    \begin{column}[T]{0.33\textwidth}
      \vspace*{1.5cm}
      \centerline{\bf Liveness at program points:}
      \begin{align*}
        %% $\Lanv{1}{\lista} = \{\epsilon\} \cup  \acar\bcar\sigma_\append\; \cup $\\
        %% $\;\;\;\;\;\;\;\;\;\;\;\acdr\Lf{\append}{1}{\bcdr\sigma_{\append}}$\\
        %% $\Lanv{1}{\listb} = \sigma \cup \Lf{\append}{2}{\bcdr\sigma_{\append}}$\\
        %% \ldots\\
        %% $\Lanv{9}{\py}  = $ \Lf{\append}{1}{\{\epsilon, \acdr\} \cup \acdr\acar\sigma_{\mathit{\!all}}} \\
      \end{align*}
    \end{column}
    
    \begin{column}[T]{0.33\textwidth}
      \vspace*{1.5cm}
      \centerline{\bf Demand summaries:}
      \begin{align*}
        &\sigma_{\xmain} = \sigma_{all}\\
        &\sigma_{\plength} = \sigma_{all} \cup \clazy\sigma_{\plength}
      \end{align*}
    \end{column}
    
    \begin{column}[T]{0.33\textwidth}
      \vspace*{1.5cm}
      \centerline{\bf Function summaries:}
      \begin{align*}
        \Lf{\plength}{1}{\sigma} = \{\clazy\sigma\} \cup \Lf{\plength}{1}{\acdr\sigma}
      \end{align*}
    \end{column}
  \end{columns}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Solution of the equations}

  View the equations as grammar rules:
 \begin{eqnarray*}
&&  \Lf{\plength }{1}{\sigma} = \Df{\plength}{1}\sigma,~\mbox{and}\\
&&   \Df{\plength}{1} = \clazy \cup \acdr\Df{\plength}{1}\clazy
       \cup \clazy\Df{\plength}{1}{\clazy}
 \end{eqnarray*}

The  solution of \Lanv{1}{\lista} is the   language  $\mathscr{L}(\Lanv{1}{\lista})$ generated    by    it.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Working of Liveness-based GC (Mark phase)}
  \begin{itemize}
  \item GC invoked at a program point $\pi$
  \item GC traverses a path $\alpha$ starting from a root variable $x$.
  \item GC consults $\Lanv{\pi}{x}$: 
    \begin{itemize}
    \item Does $\alpha \in \mathscr{L}(\Lanv{\pi}{x})$ ?
    \item If yes, then mark the current cell
    \end{itemize}
    \pause
  \item  Note  that  $\alpha$  is a  {\em  forward}-only  access  path
    \begin{itemize}
    \item consisting  only of  edges \acar\  and \acdr,  but not  \bcar\ or
      \bcdr
    \item But $\mathscr{L}(\Lanv{\pi}{x})$ has access paths marked with \bcar/\bcdr\ for \acar/\acdr\  removal
  arising from the \CONS\  rule.
    \end{itemize}
  \end{itemize}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{\bcar/\bcdr\  and \clazy\ handling}

\begin{itemize}
\item \acar\   removal from a set of access paths:
  \begin{align*}
    \alpha_1\bcar\acar\alpha_2 &\hookrightarrow
    \alpha_1\alpha_2\\
    \alpha_1\bcar \acdr\alpha_2 &\hookrightarrow
    \mbox{ drop $\alpha_1\bcar \acdr \alpha_2$ from the set}
  \end{align*}
\item \clazy\   removal from a set of access paths:

  \begin{align*}
    \clazy\sigma \hookrightarrow & \left\{ 
    \begin{array}{ll}
      \emptyset&\mbox{if}~\sigma = \emptyset\\
      \{\epsilon\} & \mbox{otherwise}
    \end{array}\right.
  \end{align*}
\end{itemize}

\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{GC decision problem}
\begin{itemize}
\item Deciding the
  membership in  a CFG augmented  with a
  fixed set of unrestricted productions.
  \begin{align*}
    \bcar\acar    \rightarrow    \epsilon\\
    \bcdr\acdr    \rightarrow   \epsilon\\
  \end{align*}
\item The problem shown to be undecidable
  \begin{itemize}
  \item Reduction from Halting problem.
  \end{itemize}
\end{itemize}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Practical \bcar/\bcdr\  simplification}

\begin{itemize}
\item The simplification is possible to do on a finite state automaton.
\item Over-approximate the CFG by an automaton
  (Mohri-Nederhoff transformation).
\item Perform \acar/\acdr\ removal on the automaton.
\item Perform \clazy\ removal.
\end{itemize}

\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Example}
  \scriptsize
  \begin{columns}[c]
    \begin{column}[T]{.5\textwidth}
      {Grammar for \Lanv{9}{\py}}
      \begin{eqnarray*}
        &&  \Lf{\plength }{1}{\sigma} = \Df{\plength}{1}\sigma,~\mbox{and}\\
        &&   \Df{\plength}{1} = \clazy \cup \acdr\Df{\plength}{1}\clazy
        \cup \clazy\Df{\plength}{1}{\clazy}
      \end{eqnarray*}
    \end{column}
    \begin{column}[T]{.5\textwidth}
      After Mohri-Nederhoff transformation
       \begin{eqnarray*}              
         \var{\Df{\plength}{1}}   &\rightarrow&   \clazy\varnew{\Df{\plength}{1}}
         \mid                 \acdr\var{\Df{\plength}{1}}                 \mid
         \clazy\var{\Df{\plength}{1}}\\  \varnew{\Df{\plength}{1}}  &\rightarrow&
         \clazy\varnew{\Df{\plength}{1}} \mid \epsilon
       \end{eqnarray*}
    \end{column}
  \end{columns}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Automaton for \Lanv{9}{y}}
\input{liveness-dfa-for-presentation.tex}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\scshape Results}
\begin{frame}{Experimental Setup}
  \begin{itemize}\itemsep1em
  \item Built a prototype consisting of:
    \begin{itemize}
    \item An ANF-scheme interpreter
    \item Liveness analyzer
    \item A single-generation copying collector.
     \end{itemize}
  \item The collector optionally uses liveness
    \begin{itemize}
    \item Marks a link during GC only if it is live.
    \end{itemize}
  \item Benchmark programs are mostly from the no-fib suite. 
  \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[b]{GC behavior as a  graph}
\only<1>{
\hspace*{-1cm}\centerline{\epsfig{file=nqueens.eps, height=6.5cm}}
}

\only<1>{      \raisebox{0mm}{\scalebox{1}{
	%%%%%%%%%%%%%%%%%%%%%Uday's stuff%%%%%%%%%%%%%%%%%%%%%%%%%
      \psset{unit=1mm}
      \psset{linewidth=.3mm}
      \begin{pspicture}(0,0)(110,0)




\putnode{activel}{origin}{90}{77}{\scriptsize Cells in active semi-space (LGC)}
\putnode{activelm}{activel}{-21}{0}{}
\putnode{activer}{origin}{90}{71}{\scriptsize Cells in active
  semi-space (RGC)}
\putnode{activerm}{activer}{-21}{0}{}
\putnode{livecurve}{origin}{51}{64}{}
\putnode{reachcurve}{origin}{59}{64}{}
\putnode{r}{origin}{96}{45}{\scriptsize No. of reachable cells}
\putnode{l}{origin}{92}{39}{\scriptsize No. of live cells}
\putnode{livecells}{origin}{66}{24}{}
\putnode{reachcells}{livecells}{0}{10}{}
\nccurve[nodesepB=-.9,angleA=180,angleB=30,linecolor=blue]{->}{activelm}{livecurve}
\nccurve[nodesepB=-.9,angleA=180,angleB=30,linecolor=red]{->}{activerm}{reachcurve}
\nccurve[nodesepB=0,angleA=180,angleB=30,linecolor=gray]{->}{r}{reachcells}
\nccurve[nodesepB=0,angleA=180,angleB=30]{->}{l}{livecells}
      \end{pspicture}}}}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%******
\section{\scshape Future Work  \& Conclusions} 
\begin{frame}{Scope for future work}
\normalsize
\begin{itemize}\itemsep2em
\item<1-> Reducing GC-time.
  \begin{itemize}
  \item Reducing re-visits to heap nodes.
  \item Basing the implementation on full Scheme, not ANF-Scheme
  \item Hybrid GC (RGC + LGC)
  \end{itemize}
\item<2-> Increasing the scope of the method.
  \begin{itemize}
   \item Higher order functions.
    \begin{itemize}
    \item Specialize all higher order functions (Firstification)
    \item Analysis on the firstified program 
    \item For partial applications, carry information about the {\em base} function
    \end{itemize}
  \end{itemize}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Conclusions}
  \begin{itemize}\itemsep1em
  \item Proposed a liveness-based GC scheme and demonstrated its efficiency in reducing number of garbage collections.
  \item LGC time is high for many programs making it currently not practical.
  \item Not covered in this talk:
    \begin{itemize}
    \item The soundness of liveness analysis.
    \item Details of undecidability proof.
    \end{itemize}
    \item A prototype implementation to demonstrate:
      \begin{itemize}
      \item the precision of the analysis.
      \item reduced heap requirement.
      \item reduced GC time for a majority of programs.
    \end{itemize}
    \item Unfinished agenda:
      \begin{itemize}
      \item Improving GC time for a larger fraction of programs.
      \item Extending scope of the method.
    \end{itemize}
  \end{itemize}
\end{frame}
\end{document}

//#include "node.h"
#include <iostream>
#include "gc.h"
#include "SchemeAST.h"
#include <assert.h>
using namespace std;
using namespace Scheme::AST;

enum GCStatus {gc_disable, gc_live, gc_freq, gc_plain} gc_status;
int maxcount = 0;

enum resType {heap, stringType, intType, boolType, errorType};
struct result
{
	result(resType t, int val)
	{
		type = t;
		res.intVal = val;
	}
	result(resType t, bool val)
	{
		type = t;
		res.boolVal = val;
	}
	result(resType t, char* val)
	{
		type = t;
		res.charVal = val;
	}
	result(resType t, void* val)
	{
		type = t;
		res.heapRef = val;
	}
	resType type;
	union
	{
		void* heapRef;
		char* charVal;
		int   intVal;
		bool  boolVal;
	}res;
};
enum exprType
{
	nilExpr,
	constIntExpr,
	constBoolExpr,
	constStringExpr,
	varExpr,
	letExpr,
	funcDefine,
	funcApplicationExpr,
	consExpr,
	carExpr,
	cdrExpr,
	nullqExpr,
	pairqExpr,
	addExpr,
	subExpr,
	mulExpr,
	divExpr,
	gtExpr,
	ltExpr,
	modExpr,
	eqExpr,
	ifExpr
};


class Simulator
{
private:
	ProgramNode* pgm;
	int conscount;
	int gcinvoke;
	//time gcstart;
	//time gcend;
	void processArguments(vector<Node*> argExprs, vector<result> &arglocs)
	{
		for(vector<Node*>::iterator arg = argExprs.begin(); arg != argExprs.end(); ++arg)
			arglocs.push_back(evaluate(*arg));

		return;
	}
public:
	Simulator(ProgramNode* p)
	{
		pgm = p;
		conscount = 0;
		gcinvoke = 0;
	}
	result evaluateNilExpr(Node*)
	{
		return result(heap, (void*)NULL);
	}
	result evaluateConstIntExpr(Node* node=NULL)
	{
		IntConstExprNode* intExpr = (IntConstExprNode*)node;
		return result(intType, intExpr->getVal());
	}
	result evaluateConstBoolExpr(Node* node=NULL)
	{
		BoolConstExprNode* boolExpr = (BoolConstExprNode*)node;
		return result(boolType, boolExpr->getVal());
	}
	result evaluateConstStringExpr(Node* node=NULL)
	{
		StrConstExprNode* stringExpr = (StrConstExprNode*)node;
		return result(stringType, stringExpr->getVal().c_str());
	}
	result evaluateVarExpr(Node* node=NULL)
	{
		IdExprNode* varExpr = (IdExprNode*)node;
		string& varName = varExpr->getName();
		char resultType = locate_var(varName.c_str());
		if( resultType == 'a')
			return result(heap, lookup_addr(varName.c_str()));
		else if (resultType == 'i')
			return result(intType, lookup_value(varName.c_str()));
		else if (resultType == 'b')
			return result(boolType, lookup_value(varName.c_str()));
		else if (resultType == 's')
			return result(stringType, lookup_value(varName.c_str()));
		else
			return result(errorType, (void*)NULL);
	}

	result evaluateIfExpr(Node* n = NULL)
	{
		IfExprNode* ifExpr = (IfExprNode*)n;
		result cond_result = evaluate(ifExpr->getCond());
		if (cond_result.res.boolVal)
			return evaluate(ifExpr->getThenPart());
		else
			return evaluate(ifExpr->getElsePart());

	}

	result evaluateLetExpr(Node* n = NULL)
	{

		LetExprNode* letExpr = (LetExprNode*)n;
		result var_res = evaluate(letExpr->getVarExpr());
		switch(var_res.type)
		{
		case intType : make_reference_value(letExpr->getVar().c_str(), int_to_void(var_res.res.intVal), 'i');
		break;
		case boolType : make_reference_value(letExpr->getVar().c_str(), int_to_void(var_res.res.boolVal), 'b');
		break;
		case stringType : make_reference_value(letExpr->getVar().c_str(), char_to_void(var_res.res.charVal), 's');
		break;
		default : make_reference_addr(letExpr->getVar().c_str(), var_res.res.heapRef);
		break;
		}

		return evaluate(letExpr->getBody());
	}

	result evaluateFuncDefineNode(Node* n = NULL)
	{
		DefineNode* fundef = (DefineNode*)n;
		return result(errorType, (void*)NULL);
	}
	result evaluateFuncApplicationExpr(Node* n = NULL)
	{
		FuncExprNode* funcApp = (FuncExprNode*)n;
		vector<result> arg_locs;
		DefineNode* funcDef = (DefineNode*)pgm->getFunction(funcApp->getFunction());
		for(vector<Node*>::iterator arg = funcApp->getArgs().begin(); arg != funcApp->getArgs().end(); ++arg)
			arg_locs.push_back(evaluate(*arg));
		make_environment(funcDef->getFuncName().c_str(), 0); //TODO : Calculate exact return point and pass it as second argument
		int i = 0;
		for(vector<result>::iterator arg = arg_locs.begin(); arg != arg_locs.end(); ++arg, ++i)
		{
			switch(arg->type)
			{
			case intType : make_reference_value((funcDef->getArgs()[i]).c_str(), int_to_void(arg->res.intVal), 'i');
			break;
			case boolType : make_reference_value((funcDef->getArgs()[i]).c_str(), int_to_void(arg->res.boolVal), 'b');
			break;
			case stringType : make_reference_value((funcDef->getArgs()[i]).c_str(), char_to_void(arg->res.charVal), 's');
			break;
			default : make_reference_addr((funcDef->getArgs()[i]).c_str(), arg->res.heapRef);
			break;
			}
		}
		//Enter function insert into call graph
		result res = evaluate(funcDef->getFunctionBody());
		//Exit function in call graph
		delete_environment();
		return res;
	}
	result evaluateConsExpr(Node* n=NULL)
	{
		BinaryPrimExprNode* primExpr = (BinaryPrimExprNode*)n;
		++conscount;
		if (gc_status != gc_disable && current_heap() <= 5)
		{
			conscount = 0;
			++gcinvoke;
			if(gc_status == gc_plain || gc_status == gc_freq)
				reachability_gc();
			else if (gc_status == gc_live )
			{
				//get handle to stack and store return point
				liveness_gc();
				//reset return point on top of stack to -1
			}
			calculate_garbage();
			detail_gc();
			//Update GC time
			dump_garbage_stats();
		}
		else
		{
			if (gc_status == gc_freq && conscount >= maxcount)
			{
				conscount = 0;
				++gcinvoke;
				reachability_gc();
				calculate_garbage();
				detail_gc();
				//Update GC time
				dump_garbage_stats();
			}
		}

		//TODO write a function to get the argument list of a primitive function and call it
		vector<result> arglocs;
		processArguments(primExpr->getArgs(), arglocs);
		result arg1 = arglocs[0];
		result arg2 = arglocs[1];
		char arg1type;
		char arg2type;
		void* a1;
		void* a2;
		switch(arg1.type)
		{
		case intType : arg1type = 'i';
		a1 = int_to_void(arg1.res.intVal);
		break;
		case boolType : arg1type = 'b';
		a1 = int_to_void(arg1.res.boolVal);
		break;
		case stringType : arg1type = 's';
		a1 = (void*)arg1.res.charVal;
		break;
		default : arg1type = 'a';
		a1 = arg1.res.heapRef;
		break;
		}
		switch(arg2.type)
		{
		case intType : arg2type = 'i';
		a2 = int_to_void(arg2.res.intVal);
		break;
		case boolType : arg2type = 'b';
		a2 = int_to_void(arg2.res.boolVal);
		break;
		case stringType : arg2type = 's';
		a2 = (void*)arg2.res.charVal;
		break;
		default : arg2type = 'a';
		a2 = arg2.res.heapRef;
		break;
		}

		return result(heap, allocate_cons(arg1type, a1, arg2type, a2));
	}
	result evaluateCarExpr(Node* n=NULL)
	{
		UnaryPrimExprNode* primExpr = (UnaryPrimExprNode*)n;
		vector<result> arglocs;
		processArguments(primExpr->getArgs(), arglocs);
		assert(arglocs.size() == 1 && arglocs[0].type == heap);
		switch (getType(arglocs[0].res.heapRef, 1))
		{
		case 2 : return result(intType, void_to_int(getCar(arglocs[0].res.heapRef, 0)));
		break;
		case 3:  return result(stringType, void_to_char(getCar(arglocs[0].res.heapRef, 0)));
		break;
		default : return result(heap, getCar(arglocs[0].res.heapRef, 0));
		break;
		}
		return result(errorType, (void*)NULL);
	}
	result evaluateCdrExpr(Node* n = NULL)
	{
		UnaryPrimExprNode* primExpr = (UnaryPrimExprNode*)n;
		vector<result> arglocs;
		processArguments(primExpr->getArgs(), arglocs);
		assert(arglocs.size() == 1 && arglocs[0].type == heap);
		switch (getType(arglocs[0].res.heapRef, 2))
		{
		case 2 : return result(intType, void_to_int(getCdr(arglocs[0].res.heapRef, 0)));
		break;
		case 3:  return result(stringType, void_to_char(getCdr(arglocs[0].res.heapRef, 0)));
		break;
		default : return result(heap, getCdr(arglocs[0].res.heapRef, 0));
		break;
		}
		return result(errorType, (void*)NULL);
	}
	result evaluateNullqExpr(Node* n = NULL)
	{
		UnaryPrimExprNode* primExpr = (UnaryPrimExprNode*)n;
		vector<result> arglocs;
		processArguments(primExpr->getArgs(), arglocs);
		assert(arglocs.size() == 1 && arglocs[0].type == heap);
		if ((arglocs[0]).res.heapRef == NULL)
			return result(boolType, 1);
		else
			return result(boolType, 0);
	}
	result evaluatePairqExpr(Node *n =NULL)
	{
		UnaryPrimExprNode* primExpr = (UnaryPrimExprNode*)n;
		vector<result> arglocs;
		processArguments(primExpr->getArgs(), arglocs);
		assert(arglocs.size() == 1 );
		if ((arglocs[0]).type == heap)
			return result(boolType, 1);
		else
			return result(boolType, 0);
	}
	result evaluateAddExpr(Node *n=NULL)
	{
		BinaryPrimExprNode* primExpr = (BinaryPrimExprNode*)n;
		vector<result> arglocs;
		processArguments(primExpr->getArgs(), arglocs);
		result arg1 = arglocs[0];
		result arg2 = arglocs[1];

		assert(arg1.type == intType && arg2.type == intType);
		return result(intType, arg1.res.intVal + arg2.res.intVal);
	}
	result evaluateSubExpr(Node *n=NULL)
	{
		BinaryPrimExprNode* primExpr = (BinaryPrimExprNode*)n;
		vector<result> arglocs;
		processArguments(primExpr->getArgs(), arglocs);
		result arg1 = arglocs[0];
		result arg2 = arglocs[1];

		assert(arg1.type == intType && arg2.type == intType);
		return result(intType, arg1.res.intVal - arg2.res.intVal);
	}
	result evaluateMulExpr(Node *n=NULL)
	{
		BinaryPrimExprNode* primExpr = (BinaryPrimExprNode*)n;
		vector<result> arglocs;
		processArguments(primExpr->getArgs(), arglocs);
		result arg1 = arglocs[0];
		result arg2 = arglocs[1];

		assert(arg1.type == intType && arg2.type == intType);
		return result(intType, arg1.res.intVal * arg2.res.intVal);
	}
	result evaluateDivExpr(Node *n=NULL)
	{
		BinaryPrimExprNode* primExpr = (BinaryPrimExprNode*)n;
		vector<result> arglocs;
		processArguments(primExpr->getArgs(), arglocs);
		result arg1 = arglocs[0];
		result arg2 = arglocs[1];

		assert(arg1.type == intType && arg2.type == intType);
		return result(intType, int(arg1.res.intVal / arg2.res.intVal));
	}
	result evaluateGTExpr(Node *n=NULL)
	{
		BinaryPrimExprNode* primExpr = (BinaryPrimExprNode*)n;
		vector<result> arglocs;
		processArguments(primExpr->getArgs(), arglocs);
		result arg1 = arglocs[0];
		result arg2 = arglocs[1];

		assert(arg1.type == intType && arg2.type == intType);
		return result(boolType, arg1.res.intVal > arg2.res.intVal);
	}
	result evaluateLTExpr(Node *n=NULL)
	{
		BinaryPrimExprNode* primExpr = (BinaryPrimExprNode*)n;
		vector<result> arglocs;
		processArguments(primExpr->getArgs(), arglocs);
		result arg1 = arglocs[0];
		result arg2 = arglocs[1];

		assert(arg1.type == intType && arg2.type == intType);
		return result(boolType, arg1.res.intVal < arg2.res.intVal);
	}
	result evaluateModExpr(Node *n=NULL)
	{
		BinaryPrimExprNode* primExpr = (BinaryPrimExprNode*)n;
		vector<result> arglocs;
		processArguments(primExpr->getArgs(), arglocs);
		result arg1 = arglocs[0];
		result arg2 = arglocs[1];

		assert(arg1.type == intType && arg2.type == intType);
		return result(intType, arg1.res.intVal % arg2.res.intVal);
	}
	result evaluateEqExpr(Node *n=NULL)
	{
		BinaryPrimExprNode* primExpr = (BinaryPrimExprNode*)n;
		vector<result> arglocs;
		processArguments(primExpr->getArgs(), arglocs);
		result arg1 = arglocs[0];
		result arg2 = arglocs[1];

		assert(arg1.type == arg2.type);
		if (arg1.type == stringType)
			return result(boolType, (arg1.res.charVal == arg2.res.charVal) || 0 == strcmp(arg1.res.charVal, arg2.res.charVal));
		else if (arg1.type == intType)
			return result(boolType, arg1.res.intVal == arg2.res.intVal);
		else if (arg1.type == boolType)
			return result(boolType, arg1.res.boolVal == arg2.res.boolVal);
		else
			return result(boolType, arg1.res.heapRef == arg2.res.heapRef);
	}

	result evaluate(Node* node)
	{
		exprType type = node->type;
		switch(type)
		{
		case nilExpr: evaluateNilExpr(node);
		break;
		case constIntExpr: evaluateConstIntExpr(node);
		break;
		case constBoolExpr: evaluateConstBoolExpr(node);
		break;
		case constStringExpr: evaluateConstStringExpr(node);
		break;
		case varExpr: evaluateVarExpr();
		break;
		case letExpr: evaluateLetExpr();
		break;
		case funcDefine: evaluateFuncDefineNode();
		break;
		case funcApplicationExpr: evaluateFuncApplicationExpr();
		break;
		case consExpr: evaluateConsExpr();
		break;
		case carExpr: evaluateCarExpr();
		break;
		case cdrExpr: evaluateCdrExpr();
		break;
		case nullqExpr: evaluateNullqExpr();
		break;
		case pairqExpr: evaluatePairqExpr();
		break;
		case addExpr: evaluateAddExpr();
		break;
		case subExpr: evaluateSubExpr();
		break;
		case mulExpr: evaluateMulExpr();
		break;
		case divExpr: evaluateDivExpr();
		break;
		case gtExpr: evaluateGTExpr();
		break;
		case ltExpr: evaluateLTExpr();
		break;
		case modExpr: evaluateModExpr();
		break;
		case eqExpr: evaluateEqExpr();
		break;
		case ifExpr: evaluateIfExpr();
		break;
		default : cout << "Undefined expression type."<<endl;
		break;
		}
		return result(errorType, (void*)NULL);
	}
};

#include <malloc.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include<vector>
#include<deque>
#include<string>
#include<iostream>
#include<fstream>
#include<unordered_map>
#include<set>

using namespace std;

typedef int state_index;
typedef set<state_index> stateset;
typedef stateset::iterator setiter;

void print_heap();
void print_buffer_data();
int is_valid_address(void*);
int lt_scan_free();
int lt_scan_freept();
void* getscan();
void update_scan();
long diff_scan_free();
state_index lookup_dfanode(string nodename);
void* followpaths(void* loc, state_index index);
state_index get_target_dfastate(state_index i1, state_index i2);
void set_car(void* loc,  void* ref);
void set_cdr(void* loc,  void* ref);
void copy_children(void* cellptr, stateset* st);
//define CHECK_BIT(var,pos) ((var) & (1<<(pos-1)))

/*-------------------------------------------------------------
 * To enable GC statistic recording. Comment #define line
 * to disable stat generation.
 * Author : Amey Karkare
 * */
#define GC_ENABLE_STATS
#if 0
#define DBG(stmt) stmt 
#else
#define DBG(stmt) (void)0
#endif


//TODO for 27-12-2013
//Create a struct for Activation Record which contains vectors of HeapRefs(HeapVars) and NonRefs(StackVars)
//Create a global stack of Activation Record struct
//All functions update this stack and return suitable values.
typedef struct Var_Heap {
    string varname;
    void* ref;
}var_heap;

typedef struct Var_Stack {
    string varname;
    void* value;
    char type;
}var_stack;

/* A better name for the environment is Activation Record */
/* Maybe it is better to combine reference and non-reference
   values through a union type*/ 
typedef struct activationRecord{
	int return_point;
	string funcname;
	vector<var_heap> heapRefs;
	vector<var_stack> nonRefs;
}actRec;
/* We use number of cons cells allocated as measure of time,
 * hence the following as clock_tick:
 */
typedef unsigned long clock_tick;
typedef struct cell_cons {
  char typecell, typecar, typecdr;   //'c' for typecell
  void *car, *cdr, *forward;
  stateset *s;
#ifdef GC_ENABLE_STATS
    /*----------------------------------------------------------------------
     * Following fields are added by Amey Karkare to
     * generate gc related statistics
     */
    /* size is used only if we support vectors */
    clock_tick created;       /* creation time of cell */
    clock_tick first_use;     /* first use time of cell */
    clock_tick last_use;      /* last use time of cell */
    char       is_reachable:1,  /* true if cell is reachable during current gc */
               is_used:1;       /* true if cell is dereferenced for use */
    /*----------------------------------------------------------------------*/
#endif
} cons;


//globals
void *freept;
void *scan;
void *buffer_live;
void *buffer_dead;
void *boundary_live;
void *boundary_dead;
unsigned long memorysize;
unsigned long newheapcells, oldheapcells;
unsigned long copycells, heapslot, garbagecells;


#ifdef GC_ENABLE_STATS
/* declarations of GC statistics related functions */
static clock_tick gc_clock();
static void tick();
void init_gc_stats();
static void clear_rch_flag();
void dump_garbage_stats();
void finish_gc_stats();
static void update_last_use(cons *cell);
/* variables to traverse the cons cells for the statistics */
static cons* array_stats;
static unsigned long last_pos;
static clock_tick current_cons_tick;

#else /* stubs */

static clock_tick gc_clock() {return 0;}
void init_gc_stats() {}
static void clear_rch_flag() {}
void dump_garbage_stats() {}
void finish_gc_stats() {}
static void update_last_use(cons *cell) {}
#endif

//Use only push_front and pop_front to insert and remove elements from actRecStack
//Use iterator to iterate over the elements of actRecStack during garbage collection
deque<actRec> actRecStack = deque<actRec>(0);
deque<actRec>::iterator actRecIter;
vector<var_heap>::iterator heapRefIter;
vector<var_stack>::iterator nonRefIter;
unordered_map<string, state_index> statemap;
state_index **state_transition_table; //Dynamically allocating a 2-D array might be error prone. See if vectors can be used instead.


int mmc=0;




/*-----Memory manager-------*/

//!!!caution remove memorysize from this function
// allocates heap in terms of NUMBER OF CONS CELLS
void allocate_heap(unsigned long size)
{
    unsigned long memorysize=size*sizeof(cons);
    if ((buffer_live=malloc(memorysize)) == 0) {
        fprintf(stderr, "Too big memory demanded. Reduce it.\n");
        exit(-1);
    }
    
    freept=buffer_live;
    scan=buffer_live;
    buffer_dead=(void*)((char*)(buffer_live)+(memorysize/2));
    boundary_live=buffer_dead;
    boundary_dead=(void*)((char*)(buffer_live)+memorysize);
    mmc=mmc+memorysize;
    newheapcells=0;oldheapcells=0;
    copycells=0;garbagecells=0;heapslot=0;

    FILE *f=fopen("./output/garbage-dump.txt","w");
    fclose(f);

#ifdef GC_ENABLE_STATS
    array_stats = (cons*)buffer_live;
#endif
}

void calculate_garbage(){
  garbagecells=garbagecells+(oldheapcells-copycells);
}

void detail_gc(){
	FILE *f=fopen("./output/garbage-dump.txt","a");
	unsigned long curcells=oldheapcells;
	if (oldheapcells==0) curcells=newheapcells;     //for gc-disable
	garbagecells=curcells-copycells;
	fprintf(f,"%lu %lu %lu %lu %lu %lu %lu mmc=%d\n", curcells, curcells*sizeof(cons), copycells,
			copycells*sizeof(cons), garbagecells, garbagecells*sizeof(cons), heapslot, mmc);
	fclose(f);
}


void swap_buffer()
{
    void *temp;
#ifdef GC_ENABLE_STATS
    /* point to the old buffer to collect statistics */
    array_stats = (cons*)buffer_live;
    last_pos = ((cons*)freept - (cons*)buffer_live);
    clear_rch_flag();
#endif
    //swap buffers
    temp=buffer_dead;
    buffer_dead=buffer_live;
    buffer_live=temp;
    //swap buffer boundaries
    temp=boundary_dead;
    boundary_dead=boundary_live;
    boundary_live=temp; 
    //set free and scan pointers
    freept=buffer_live;
    scan=buffer_live;
  
    oldheapcells=newheapcells;
    newheapcells=0;copycells=0;
    heapslot=0;
}

void update_free(unsigned int size)
{
    freept=(void *) ((char*)freept + size);
}

int check_space(int size)
{
    if (((char*)boundary_live - (char*)freept) >= size)
    	return 1;
    else
        return 0;
}



void* return_null()
{
  return NULL;
}

void* dup_cons(cons* cell) 
{
    if (check_space(sizeof(cons))==0)
    { 
      fprintf(stderr,"Not Sufficient Memory - cons\n"); 
      return NULL;
    }
    cons *conscell=(cons *)freept;
    update_free(sizeof(cons));
    newheapcells=newheapcells+1;
    memcpy(conscell, cell, sizeof(cons));
    return conscell;
}

void* allocate_cons(char cartype, void* addrcar, char cdrtype, void* addrcdr)
{
#ifdef GC_ENABLE_STATS
    /* cons clock tick */
    tick();
#endif
    if (check_space(sizeof(cons))==0)
    { 
      fprintf(stderr,"No Sufficient Memory - cons\n"); 
      return NULL;
    }
    cons *conscell=(cons *)freept;
    update_free(sizeof(cons));
    newheapcells=newheapcells+1;
    
    conscell->typecar=cartype;
    conscell->typecdr=cdrtype;
    conscell->forward=NULL;
    conscell->car=addrcar;
    conscell->cdr=addrcdr;
    conscell->s = new stateset();
 #ifdef GC_ENABLE_STATS
    conscell->created = gc_clock();   
    conscell->is_reachable = 0; 
    conscell->is_used = 0;      
#endif
        
    return conscell;
}


//////////////environment (activation record stack)


void empty_environment(string functionname){
    actRec newenv;
    newenv.return_point=-1;
    newenv.funcname = functionname;
    newenv.heapRefs = vector<var_heap>(0);
    newenv.nonRefs  = vector<var_stack>(0);
    actRecStack.push_front(newenv);
    mmc=mmc+(sizeof(actRec));
}

void make_environment(char *functionname, int returnpoint){
    actRec newenv;
    actRecStack.front().return_point = returnpoint;
    newenv.return_point=-1;
    newenv.funcname=functionname;
    //newenv.heapRefs;
    //newenv.nonRefs;
    actRecStack.push_front(newenv);
    mmc=mmc+(sizeof(actRec));
}

void delete_environment(){
   
    actRecStack.pop_front();
    mmc=mmc-(sizeof(actRec));
    actRecStack.front().return_point=-1; //reset
}

void set_return_point(int pt){
    actRecStack.front().return_point = pt;
  
}

//rename to return_top_of_stack
actRec& return_stack(){
    actRecIter = actRecStack.begin();
    return actRecStack.front();
}

actRec& get_next_activation_record()
{
	++actRecIter;
	return *actRecIter;
}

int is_end_of_activation_record_stack()
{
	if (actRecIter == actRecStack.end())
		return 1;
	else
		return 0;
}

int is_empty_heap_ref_vector()
{
	if ((*actRecIter).heapRefs.empty())
		return 1;
	else 
		return 0;
}

var_heap& get_heap_ref_vector()
{
	heapRefIter = (*actRecIter).heapRefs.begin();
	return *heapRefIter;
}

var_heap& get_next_heap_ref_vector()
{
	++heapRefIter;
	return *heapRefIter;
}

int is_end_of_heap_ref_vector()
{
	if (heapRefIter == (*actRecIter).heapRefs.end())
		return 1;
	else
		return 0;
}

int is_empty_non_ref_vector()
{
	if ((*actRecIter).nonRefs.empty())
		return 1;
	else 
		return 0;
}

var_stack& get_non_ref_vector()
{
	nonRefIter = (*actRecIter).nonRefs.begin();
	return *nonRefIter;
}

var_stack& get_next_non_ref_vector()
{
	++nonRefIter;
	return *nonRefIter;
}

int is_end_of_non_ref_vector()
{
	if (nonRefIter == (*actRecIter).nonRefs.end())
		return 1;
	else
		return 0;
}

//!!!!!caution update it to check for already existing variable in same environment
void make_reference_addr(char *var, void* addr){
	int found=0;
	vector<var_heap>& vh=actRecStack.front().heapRefs;
	vector<var_heap>::iterator it = vh.begin();
	while(it != vh.end()) {

		if (strcmp(it->varname.c_str(),var)==0)
		{
			it->ref=addr;
			found=1;
			break;
		}
		++it;
	}
	if(found==0){
		var_heap newref;
		newref.varname=var;
		newref.ref=addr;

		actRecStack.front().heapRefs.push_back(newref);
		mmc=mmc+(sizeof(var_heap));
	}

}

void make_reference_value(char *var, void* val, char type)
{
	int found=0;
	vector<var_stack>& vs=actRecStack.front().nonRefs;
	if (!vs.empty())
	{
		vector<var_stack>::iterator it = vs.begin();
		while(it != vs.end())
		{
			if (strcmp(it->varname.c_str(),var)==0)
			{
				it->value = val;
				it->type = type;
				found=1;
				break;
			}
			++it;
		}
	}

	if(found==0)
	{
		var_stack newref;
		newref.varname=var;
		newref.value=val;
		newref.type=type;
		actRecStack.front().nonRefs.push_back(newref);
		mmc=mmc+(sizeof(var_stack));
	}
}

char locate_var(char *var)
{

	vector<var_heap> vh = actRecStack.front().heapRefs;
	vector<var_heap>::iterator it = vh.begin();
	while(it != vh.end())
	{
		if(strcmp(it->varname.c_str(),var)==0)
			return 'a';

		++it;
	}

	vector<var_stack> vs=actRecStack.front().nonRefs;
	vector<var_stack>::iterator its = vs.begin();
	while(its != vs.end())
	{
		if (strcmp(its->varname.c_str(),var)==0)
			return its->type;

		++its;
	}

	cout << "Element "<< var <<" not found." << endl;
	return 'n'; /*Element not found.*/
}


void* lookup_addr(char *var)
{
  vector<var_heap> vh=actRecStack.front().heapRefs;
  vector<var_heap>::iterator it = vh.begin();
  while(it != vh.end())
    {
      if (strcmp(it->varname.c_str(),var)==0) 
	{
	  return it->ref;
	}
      ++it;
    }

  return NULL;
}

void* lookup_value(char *var)
{
  vector<var_stack> vs=actRecStack.front().nonRefs;
  vector<var_stack>::iterator it = vs.begin();
  while(it != vs.end()) 
    {
      if (strcmp(it->varname.c_str(),var)==0) 
	{
	  return it->value;
	}
      ++it;
    }
  return (void*)-1;
}

int set_reference(var_heap , char *var, void* newref)
{
  vector<var_heap>& vh = actRecIter->heapRefs;
  vector<var_heap>::iterator it = vh.begin();
  while(it != vh.end())
    {
      if (strcmp(it->varname.c_str(), var) == 0)
	{
	  it->ref = newref;
	  return 1;
	}
      ++it;
    }
  return 0;
} 

int remove_reference(char *var, var_heap)
{
	vector<var_heap>& vh = actRecIter->heapRefs;
	vector<var_heap>::iterator it = vh.begin();
	while(it != vh.end())
	{
		if (strcmp(it->varname.c_str(), var) == 0)
		{
			it->ref = NULL;
			return 1;
		}
		++it;
	}
	return 0;
}


//utility

void printval(void *ref)
{
	if (ref == NULL)
		return;
	if (!is_valid_address(ref)) //Check added for liveness based GC as this might not be a valid pointer to chase. In case of reachability all addresses will be valid.
		{
			cout <<"Invalid address "<< ref<<endl;
			return;
		}

	cons *cref;
	cref=(cons *)ref;
#ifdef GC_ENABLE_STATS
	update_last_use(cref);
#endif

	printf("(");
	if(cref->typecar=='i')
		printf("%p", (int*)cref->car);
	else if(cref->typecar=='s')
		printf("%s", (char*)cref->car);
	else
		printval(cref->car);
	printf(".");

	if(cref->typecdr=='i')
		printf("%p", (int*)cref->cdr);
	else if(cref->typecdr=='s')
		printf("%s", (char*)cref->cdr);
	else
		printval(cref->cdr);
	printf(")");
}

long current_heap()
{
  return ((char*)boundary_live - (char*)freept)/sizeof(cons);
}

////garbage collector support functions for python module
int sizeof_cons() 
{
    return sizeof(cons);
}

void* getCar(void* ref, char fromGC)
{
    cons *conscell=(cons*)ref;
#ifdef GC_ENABLE_STATS
    if (!fromGC)
        update_last_use(conscell);
#endif
    if (conscell == NULL) //Seems to be a hack should ensure that Nil is handled correctly
	{
	  return NULL;
	}
    void* car=conscell->car;
    return car;
}



void* getCdr(void* ref, char fromGC)
{
    cons *conscell=(cons*)ref;
#ifdef GC_ENABLE_STATS
    if (!fromGC)
        update_last_use(conscell);
#endif
    if (conscell == NULL)//Seems to be a hack should ensure that Nil is handled correctly
	{
	  return NULL;
	}
    void* cdr=conscell->cdr;
    return cdr;
}

int isEqualCons (cons* v1,cons* v2, char fromGC)
{
#ifdef GC_ENABLE_STATS
    if (!fromGC)
    {
        update_last_use(v1);
        update_last_use(v2);
    }
    
#endif
    
    if (v1==v2) return 1;
    else return 0;
}

//getType function: -1 for NULL, 1 for cons, 2 for int, 3 for string
int getType(void* node, int field)
{	
    if (node==NULL)  return -1;
    cons * conscell=(cons*)node;
    if (field==1){
        if(conscell->typecar=='i' ) return 2;
        else if(conscell->typecar=='s' ) return 3;
        else if(conscell->car==NULL) return -1;
        else return 1;
    }
    else if (field==2){
        if(conscell->typecdr=='i' ) return 2;
        if(conscell->typecdr=='s' ) return 3;
        else if(conscell->cdr==NULL) return -1;
        else return 1;
    }
    return 0;
}


//garbage collector functions  
void* copy(void* node)
{
  void *addr;
  if(node==NULL) return NULL;
  else 
    {	
      heapslot=heapslot+1;
      cons *conscell=(cons*)node;
#ifdef GC_ENABLE_STATS
      conscell->is_reachable = 1;
#endif		
      if((conscell->forward >= buffer_live) &&
	 (boundary_live > conscell->forward))
		  return (conscell->forward);

      addr = dup_cons(conscell);
      conscell->forward=addr;
      copycells=copycells+1;
      return addr;
    }

  return return_null();
}

int copy_scan_children(void* node)
{
	void *addr=NULL;
	cons *conscell=(cons*)node;
	if (conscell->typecar=='a')
	{
		addr=copy(conscell->car);
		conscell->car=addr;
	}
	if (conscell->typecdr=='a')
	{
		addr=copy(conscell->cdr);
		conscell->cdr=addr;
	}

	return (sizeof(cons));
}

void reachability_gc()
{

  swap_buffer();
  
  for (deque<actRec>::iterator stackit = actRecStack.begin();stackit != actRecStack.end(); ++stackit)
  {
	  for(vector<var_heap>::iterator vhit = stackit->heapRefs.begin(); vhit != stackit->heapRefs.end(); ++vhit)
	  {
		  void *reference=vhit->ref;
		  void *addr=copy(reference);
		  vhit->ref = addr;
	  }
  }
  //chasing reachable cells from roots
  while(lt_scan_freept()==1)
    {
      copy_scan_children(getscan());
      update_scan();
    }

  return;
}

void liveness_gc_dfs()
{

  swap_buffer();
  for (deque<actRec>::iterator stackit = actRecStack.begin();stackit != actRecStack.end(); ++stackit)
    {
      for(vector<var_heap>::iterator vhit = stackit->heapRefs.begin(); vhit != stackit->heapRefs.end(); ++vhit)
      {
    	  string nodeName = "L/" + to_string(stackit->return_point) + "/" + vhit->varname;
    	  unordered_map<string, state_index>::const_iterator got = statemap.find(nodeName);

    	  if (got != statemap.end())
    	  {
    		  void *addr   = followpaths(vhit->ref, got->second);
    		  vhit->ref = addr;
    	  }
      }
    }

  return;
}

void* followpaths(void* loc, state_index index)
{
  void* loccopy = copy(loc);
  state_index a0 = get_target_dfastate(index, 0);
  if (a0 > 0)
  {
	  // If using type information we can ensure that the type is always address type, this check can be eliminated
	  // set the liveness for operators operating on unboxed values to NULL so that it will never come here.
	  if (getType(loccopy,1) == 1)
	  {
		  void* newloc = getCar(loc, 1);
		  void* addr = followpaths(newloc, a0);
		  set_car(loccopy, addr);
	  }
  }
 
  state_index a1 = get_target_dfastate(index, 1);
  if (a1 > 0)
  {
	  if (getType(loccopy,2) == 1)
	  {
		  void* newloc = getCdr(loc, 1);
		  void* addr = followpaths(newloc, a1);
		  set_cdr(loccopy, addr);
	  }
  }

  return loccopy;
}

bool check_processed(void* addr, stateset* s);

////Liveness with BFS
int copy_scan_children_liveness(void* node)
{
  void *addr=NULL;
  cons *conscell=(cons*)node;
  stateset* a0 = new stateset();
  stateset* a1 = new stateset();
  state_index t = 0;

  for (setiter i = conscell->s->begin(); i != conscell->s->end(); ++i)
  {
	  if ((t = get_target_dfastate(*i, 0)))
	  {
		  a0->insert(t);
	  }
	  if ((t = get_target_dfastate(*i, 1)))
	  {
		  a1->insert(t);
	  }
  }
  if (conscell->typecar=='a' && !a0->empty())
  {
	  addr=copy(conscell->car);
	  if (addr && !check_processed(addr, a0))
	  {
		  cons* c = (cons*)addr;
		  c->s->insert(a0->begin(), a0->end());
	  }
	  conscell->car=addr;
  }
 
  if (conscell->typecdr=='a' && !a1->empty())
  {
	  addr=copy(conscell->cdr);
	  if (addr && !check_processed(addr, a1))
	  {
		  cons* c = (cons*)addr;
		  c->s->insert(a1->begin(), a1->end());
	  }
	  conscell->cdr=addr;
  }
  delete a0;
  delete a1;

  return (sizeof(cons));
}

bool check_processed(void* addr, stateset* s)
{
  bool retval = false;
  if (addr < scan && addr > buffer_live) //if the cons cell was already processed
    {
      cons* cref = (cons*)addr;
      stateset* temp0 = new stateset();
      stateset* temp1 = new stateset();
      for (setiter it = s->begin(); it != s->end(); ++it)
    	  if (cref->s->find(*it) == cref->s->end()) //if this state was not reached earlier for this cons cell
    	  {
    		  cref->s->insert(*it);
    		  state_index t0 = get_target_dfastate(*it, 0);
    		  if (t0)
    			  temp0->insert(*it);
    		  state_index t1 = get_target_dfastate(*it, 1);
    		  if (t1)
    			  temp1->insert(*it);
    	  }
      if (cref->typecar=='a' && !temp0->empty())
      {
    	  void* newaddr=copy(cref->car);
    	  if (newaddr > scan)
    	  {
    		  cons* c = (cons*)newaddr;
    		  c->s->insert(temp0->begin(), temp0->end());
    	  }
    	  else
    		  check_processed(newaddr, temp0);
    	  cref->car=newaddr;
      }
      if (cref->typecdr=='a' && !temp1->empty())
      {
    	  void* newaddr=copy(cref->cdr);
    	  if (newaddr > scan)
    	  {
    		  cons* c = (cons*)newaddr;
    		  c->s->insert(temp1->begin(), temp1->end());
    	  }
    	  else
    		  check_processed(newaddr, temp1);
    	  cref->cdr=newaddr;
      }
      delete temp0;
      delete temp1;
      retval = true;
    }
  return retval;
}



/*void clear_set(stateset* s)
{
  stateset temp;
  s->swap(temp);
}*/

void liveness_gc()
{

  swap_buffer();
  for (deque<actRec>::iterator stackit = actRecStack.begin();stackit != actRecStack.end(); ++stackit)
  {
	  for(vector<var_heap>::iterator vhit = stackit->heapRefs.begin(); vhit != stackit->heapRefs.end(); ++vhit)
	  {
		  string nodeName = "L/" + to_string(stackit->return_point) + "/" + vhit->varname;
		  unordered_map<string, state_index>::const_iterator got = statemap.find(nodeName);
		  if (got != statemap.end())
		  {
			  void* addr = copy(vhit->ref);
			  if (addr)
			  {
				  cons* c = (cons*) addr;
				  c->s->insert(got->second);
			  }
			  vhit->ref = addr;
		  }
	  }
  }
  //chasing reachable cells from roots
  while(lt_scan_freept()==1)//
  {
	  copy_children(scan, ((cons*)scan)->s);
	  update_scan();
  }
//  cout <<"Printing heap after GC"<<endl;
//  print_heap();

  return;
}

void copy_children(void* cellptr, stateset* st)
{
	stateset s0;
	stateset s1;

	for(setiter i = st->begin(); i != st->end(); ++i)
	{
		state_index t = get_target_dfastate(*i, 0);
		if (t > 0)
			s0.insert(t);
		t = get_target_dfastate(*i, 1);
		if (t > 0)
			s1.insert(t);
	}

	//process car field
	if(!s0.empty())
	{
		if (getType(cellptr, 1) == 1)//Do this only if car is address type
		{
			void* fpt = freept;
			void* newaddr = copy(((cons*)cellptr)->car);
			if(newaddr && newaddr == fpt) //A cell was copied from the dead buffer to live buffer
			{
				((cons*)newaddr)->s->insert(s0.begin(), s0.end());
			}
			else if (newaddr > scan) //forwarded pointer but not yet processed in the live buffer
			{
				((cons*)newaddr)->s->insert(s0.begin(), s0.end());
			}
			else if (newaddr) //forwarded pointer which has already been processed in the live buffer
			{
				stateset s_new;
				stateset *s_child = ((cons*)newaddr)->s;
				for(setiter i = s0.begin(); i != s0.end(); ++i)
					if (s_child->find(*i) == s_child->end())
						s_new.insert(*i);
				if (!s_new.empty())
				{
					copy_children(newaddr, &s_new);
					((cons*)newaddr)->s->insert(s_new.begin(), s_new.end());
				}
			}
			((cons*)cellptr)->car = newaddr;
		}
	}

	//process cdr field
	if(!s1.empty())
	{
		if (getType(cellptr, 2) == 1)//Do this only if cdr is address type
		{
			void* fpt = freept;
			void* newaddr = copy(((cons*)cellptr)->cdr);

			if(newaddr && newaddr == fpt)//A cell was copied from the dead buffer to live buffer
			{
				((cons*)newaddr)->s->insert(s1.begin(), s1.end());
			}
			else if (newaddr > scan) //forwarded pointer but not yet processed in the live buffer
			{
				((cons*)newaddr)->s->insert(s1.begin(), s1.end());
			}
			else if(newaddr)//forwarded pointer which has already been processed in the live buffer
			{
				stateset s_new;
				stateset *s_child = ((cons*)newaddr)->s;
				for(setiter i = s1.begin(); i != s1.end(); ++i)
					if (s_child->find(*i) == s_child->end())
						s_new.insert(*i);
				if (!s_new.empty())
				{
					copy_children(newaddr, &s_new);
					((cons*)newaddr)->s->insert(s_new.begin(), s_new.end());
				}
			}
			((cons*)cellptr)->cdr = newaddr;
		}
	}
 return;
}

//int dfs = 1;
//void liveness()
//{
//  if (!dfs)
//    {
//      cout << "DFS based GC " << endl;
//      liveness_gc_dfs();
//    }
//  else
//    {
//      cout << "BFS based GC " << endl;
//      liveness_gc_bfs();
//    }
//}
//////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//For debugging 
void print_heap()
{
	cout <<"----------------------------------------------------------------------------"<<endl;
	for (deque<actRec>::iterator stackit = actRecStack.begin();stackit != actRecStack.end(); ++stackit)
	{
		cout << "In function " << stackit->funcname << endl;
		for(vector<var_heap>::iterator vhit = stackit->heapRefs.begin(); vhit != stackit->heapRefs.end(); ++vhit)
		{
			if (vhit->ref)
			{
				cout << "Printing " << vhit->varname << " = ";
				printval(vhit->ref);
				cout << endl;
			}
		}
	}
	cout <<"----------------------------------------------------------------------------"<<endl;
}
void print_buffer_data()
{
  cout << "Buffer Live "<< buffer_live << endl;
  cout << "Boundary Live "<< boundary_live << endl;
  cout << "Scan ptr " << scan << endl;
  cout << "Free ptr "<< freept << endl;
  cout << "Buffer Dead "<< buffer_dead << endl;
  cout << "Boundary Dead "<< boundary_dead << endl;
  cout << "Number of cells copied " << ((char*)freept - (char*)buffer_live)/sizeof(cons) << endl;
}
int is_valid_address(void* addr)
{
  return ((addr >= buffer_live) && (addr < boundary_live));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////garbage collection function for python module garbagecollector
int isSame (void* loc1, void *loc2)
{
  if (loc1 == loc2)  return 1;
  else    return 0;
}


int isCar(void *loc){
    int type=getType(loc,1);
    return type;
}

int isCdr(void *loc){
    int type=getType(loc,2);
    return type;
}

int lt_scan_free(){
  if ((char*)scan <= (char*)boundary_live)  return 1;
    else    return 0;
}


long diff_scan_free()
{
  return ((char*)freept - (char*)scan)/sizeof(cons);
}

void set_car(void* loc,  void* ref){
 	cons *conscell=(cons*)loc;
	conscell->car=ref;
}


void set_cdr(void* loc,  void* ref){
 	cons *conscell=(cons*)loc;
	conscell->cdr=ref;
}
int is_null_stack(actRec )
{
    if (actRecStack.empty())  return 1;
    else 	return 0;
}

int is_null_binding(var_heap *bind)
{
  if (bind==NULL)  return 1;
  else 	return 0;
}


void* int_to_void(int val)
{
  void* newval= (void*)((long)val); // Added a double cast to remove warnings of casting int to pointer and vice-versa.
  return newval;
}

void* char_to_void(char* str)
{
  void* newval=str;
  return newval;
}
 
int void_to_int(void *val)
{
  int newval=(int)((long)val); // Added a double cast to remove warnings of casting int to pointer and vice-versa.
  return newval;
}

char* void_to_char(void *val)
{
  char* newval= (char*)val;
  return newval;
}

cons* void_to_cons(void* val)
{
	cons* cell = (cons*)val;
	return cell;
}
long void_to_long(void* val)
{
  long ret = (long)val;
    return ret;
}
void* long_to_void(long val)
{
  void* newval = (void*) val;
  return newval;
}

void update_scan()
{
  scan=(void*)((char*)scan+sizeof(cons));
}

void* getscan()
{
  return scan;
}

void* getfree()
{
  return freept;
}

int lt_scan_freept()
{
  if ((char*)scan < (char*)freept)  return 1;
  else    return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Functions for handling liveness based GC

void read_state_map_from_file(string filepath)
{
  
  ifstream state_map_file;
  string line;
  
  state_map_file.open(filepath);
  while(getline(state_map_file, line))
    {
      string key;
      state_index value;
      state_index start = 0, end = 0;
      end = line.find(':', start);
      key = line.substr(start, end);
      start = end + 1;
      end = 0;
      end = line.find(';', start);
      value = stol(line.substr(start, end));
      statemap[key] = value;
    }
  state_map_file.close();
  return;
}

void read_state_transition_table_from_file(string filepath)
{
 
  ifstream state_transition_file;
  string line;
  
  state_transition_file.open(filepath);
  while(getline(state_transition_file, line))
    {
      state_index index1, index2, value;
      state_index start = 0, end = 0;
      end = line.find(':', start);
      index1 = stol(line.substr(start, end));
      start = end + 1;
      end = 0;
      end = line.find(':', start);
      index2 = stol(line.substr(start, end));
      start = end + 1;
      end = 0;
      end = line.find(";", start);
      value = stol(line.substr(start, end));
      state_transition_table[index1][index2] = value;
      //cout << "Translated to "<<index1<<" "<<index2<<" "<<value<<endl;
    }
  state_transition_file.close();
  return;
}

void initialize (string program_name, state_index numkeys)
{
  state_transition_table = new state_index*[numkeys];
  for (state_index i = 0; i < numkeys; ++i)
    {
      state_transition_table[i] = new state_index[2];
      state_transition_table[i][0]=0;
      state_transition_table[i][1]=0;
    }
      
  string filepath = "./fsmdump-" + program_name;
  read_state_map_from_file(filepath + "-state-map");
  read_state_transition_table_from_file(filepath + "-state-transition-table");
 
  return;
}

void cleanup(state_index numkeys)
{
   for (int i = 0; i < numkeys; ++i)
    {
      delete [] state_transition_table[i];
    }
   delete [] state_transition_table;
}

state_index lookup_dfanode(string nodename)
{
  return statemap[nodename];
}

state_index get_target_dfastate(state_index i1, state_index i2)
{
  return state_transition_table[i1][i2];
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef GC_ENABLE_STATS
/* Garbage collection statistics */
/* author : Amey Karkare */
static clock_tick gc_clock() 
{
    return current_cons_tick;
}

static void tick() 
{
    ++current_cons_tick;
}

static const char* gc_stats_filename = "./output/GC_STATS.txt";
static FILE* gc_stats_outfile;
void init_gc_stats()
{                           
    DBG(printf("init_gc_stats ==>\n"));

    gc_stats_outfile = fopen(gc_stats_filename, "w");
    fprintf(gc_stats_outfile, "T_gc\t| Address\t| Tnew\t| T_Fu\t| T_Lu \n");

    DBG(printf("<== init_gc_stats\n"));    
}

static void clear_rch_flag()
{
    DBG(printf("clear_rch_flag ==>\n"));
    unsigned long i;
    /* clear reachable flag for all cells before GC starts */
    for (i = 0; i < last_pos; i++)
        array_stats[i].is_reachable = 0;
    DBG(printf("<== clear_rch_flag\n"));
}

#define TIME_ms(tm) (tm) // time in cons ticks.
static void dump_cell_stats(cons* gs)
{
    if (gs->is_used)
    {
        fprintf(gc_stats_outfile,
                /*GC  | Cell  |Create| First | Last */
                /*Time| Addrs |Time  | Use   | Use  */
                "%lu\t| %p  \t| %lu\t| %lu\t | %lu\t\n",
                TIME_ms(gc_clock()), gs,
                TIME_ms(gs->created), TIME_ms(gs->first_use),
                TIME_ms(gs->last_use));
    }
    else
    { /* first and last use are -1 */
        fprintf(gc_stats_outfile,
                /*GC  | Cell  |Create| First | Last */
                /*Time| Addrs |Time  | Use   | Use  */
                "%lu\t| %p  \t| %lu\t| -1\t  | -1\t \n",
                TIME_ms(gc_clock()), gs, TIME_ms(gs->created));
    }
}

void dump_garbage_stats()
{
    static int num_gcs;
    
    DBG(printf("dump_garbage_stats ==>\n"));
    fprintf(gc_stats_outfile, "//--- GC #%d | %lu \n",
            ++num_gcs, TIME_ms(gc_clock()));
    unsigned long i = 0;
    for (i = 0; i < last_pos; ++i)
    {
        if (!array_stats[i].is_reachable)
        {
            /* dump the statistics for unreachable cells */
            dump_cell_stats(&array_stats[i]);
        }
    }
    DBG(printf("<== dump_garbage_stats\n"));
}

void finish_gc_stats()
{
    DBG(printf("finish_gc_stats ==>"));
    unsigned long i;
    array_stats = (cons*)buffer_live;
    last_pos = ((cons*)freept - (cons*)buffer_live);

    /* dump the statistics for all cells */
    fprintf(gc_stats_outfile, "//--- Finish | %lu\n", TIME_ms(gc_clock()));
    for (i = 0; i < last_pos; i++)
        dump_cell_stats(&array_stats[i]);

    fclose(gc_stats_outfile);
}

static void update_last_use(cons *cell)
{
    DBG(printf("updating last use(%p) ==>\n", cell));    
    if (cell == NULL)
	//cout << "No need to count for a NULL list" << endl;
	return;    
    assert(cell); // only valid cells allowed
    
    if (!cell->is_used)
    {
        cell->is_used = 1;
        cell->first_use = cell->last_use = gc_clock();
    }
    else
    {
        cell->last_use = gc_clock();
    }
    
    DBG(printf("<== updating last use(%p)\n", cell));
}



#endif

